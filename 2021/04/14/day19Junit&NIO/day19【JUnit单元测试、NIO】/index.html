<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eniac286.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="day19【Junit单元测试、NIO】今日内容 Junit单元测试 NIO  教学目标  能够使用Junit进行单元测试  能够说出同步和异步的概念  能够说出阻塞和非阻塞的概念  能够创建和使用ByteBuffer  能够使用MappedByteBuffer实现高效读写  能够使用ServerSocketChannel和SocketChannel实现连接并收发信息  第一章 Junit单元测试">
<meta property="og:type" content="article">
<meta property="og:title" content="Eniac286">
<meta property="og:url" content="https://eniac286.github.io/2021/04/14/day19Junit&NIO/day19%E3%80%90JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81NIO%E3%80%91/index.html">
<meta property="og:site_name" content="Eniac286">
<meta property="og:description" content="day19【Junit单元测试、NIO】今日内容 Junit单元测试 NIO  教学目标  能够使用Junit进行单元测试  能够说出同步和异步的概念  能够说出阻塞和非阻塞的概念  能够创建和使用ByteBuffer  能够使用MappedByteBuffer实现高效读写  能够使用ServerSocketChannel和SocketChannel实现连接并收发信息  第一章 Junit单元测试">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/17.png">
<meta property="og:image" content="c:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/18.png">
<meta property="og:image" content="c:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/19.png">
<meta property="og:image" content="c:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/10.png">
<meta property="article:published_time" content="2021-04-14T15:49:53.644Z">
<meta property="article:modified_time" content="2020-03-17T14:44:54.299Z">
<meta property="article:author" content="Dara Yoon">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/17.png">

<link rel="canonical" href="https://eniac286.github.io/2021/04/14/day19Junit&NIO/day19%E3%80%90JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81NIO%E3%80%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Eniac286</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Eniac286</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">风物长宜放眼量</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-时间轴">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间轴</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eniac286.github.io/2021/04/14/day19Junit&NIO/day19%E3%80%90JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81NIO%E3%80%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dara Yoon">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Eniac286">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-14 23:49:53" itemprop="dateCreated datePublished" datetime="2021-04-14T23:49:53+08:00">2021-04-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="day19【Junit单元测试、NIO】"><a href="#day19【Junit单元测试、NIO】" class="headerlink" title="day19【Junit单元测试、NIO】"></a>day19【Junit单元测试、NIO】</h1><h2 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h2><ul>
<li>Junit单元测试</li>
<li>NIO</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够使用Junit进行单元测试</li>
<li><input disabled="" type="checkbox"> 能够说出同步和异步的概念</li>
<li><input disabled="" type="checkbox"> 能够说出阻塞和非阻塞的概念</li>
<li><input disabled="" type="checkbox"> 能够创建和使用ByteBuffer</li>
<li><input disabled="" type="checkbox"> 能够使用MappedByteBuffer实现高效读写</li>
<li><input disabled="" type="checkbox"> 能够使用ServerSocketChannel和SocketChannel实现连接并收发信息</li>
</ul>
<h1 id="第一章-Junit单元测试"><a href="#第一章-Junit单元测试" class="headerlink" title="第一章 Junit单元测试"></a>第一章 Junit单元测试</h1><h2 id="1-1-什么是Junit"><a href="#1-1-什么是Junit" class="headerlink" title="1.1 什么是Junit"></a>1.1 什么是Junit</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Junit是什么</span><br><span class="line">    *  Junit是Java语言编写的第三方单元测试框架(工具类)</span><br><span class="line">    *  类库 ==&gt; 类  junit.jar</span><br><span class="line"></span><br><span class="line">单元测试概念</span><br><span class="line">    * 单元：在Java中，一个类、一个方法就是一个单元</span><br><span class="line">    * 单元测试：程序员编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试。</span><br><span class="line"></span><br><span class="line">Junit单元测试框架的作用</span><br><span class="line">    * 用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性。</span><br><span class="line">    * 能够让方法独立运行起来。</span><br><span class="line"></span><br><span class="line">Junit单元测试框架的使用步骤</span><br><span class="line">    * 编写业务类，在业务类中编写业务方法。比如增删改查的方法</span><br><span class="line">    * 编写测试类，在测试类中编写测试方法，在测试方法中编写测试代码来测试。</span><br><span class="line">        * 测试类的命名规范：以Test开头，以业务类类名结尾，使用驼峰命名法</span><br><span class="line">            * 每一个单词首字母大写，称为大驼峰命名法，比如类名，接口名...</span><br><span class="line">            * 从第二单词开始首字母大写，称为小驼峰命名法，比如方法命名</span><br><span class="line">            * 比如业务类类名：ProductDao，那么测试类类名就应该叫：TestProductDao</span><br><span class="line">        * 测试方法的命名规则：以test开头，以业务方法名结尾</span><br><span class="line">            * 比如业务方法名为：save，那么测试方法名就应该叫：testSave</span><br><span class="line"></span><br><span class="line">测试方法注意事项</span><br><span class="line">    * 必须是<span class="keyword">public</span>修饰的，没有返回值，没有参数</span><br><span class="line">    * 必须使用JUnit的注解<span class="meta">@Test</span>修饰</span><br><span class="line"></span><br><span class="line">如何运行测试方法</span><br><span class="line">    * 选中方法名 --&gt; 右键 --&gt; Run <span class="string">&#x27;测试方法名&#x27;</span>  运行选中的测试方法</span><br><span class="line">    * 选中测试类类名 --&gt; 右键 --&gt; Run <span class="string">&#x27;测试类类名&#x27;</span>  运行测试类中所有测试方法</span><br><span class="line">    * 选中模块名 --&gt; 右键 --&gt; Run <span class="string">&#x27;All Tests&#x27;</span>  运行模块中的所有测试类的所有测试方法</span><br><span class="line"></span><br><span class="line">如何查看测试结果</span><br><span class="line">    * 绿色：表示测试通过</span><br><span class="line">    * 红色：表示测试失败，有问题</span><br></pre></td></tr></table></figure>



<h2 id="1-2-Junit常用注解-Junit4-x版本"><a href="#1-2-Junit常用注解-Junit4-x版本" class="headerlink" title="1.2 Junit常用注解(Junit4.x版本)"></a>1.2 Junit常用注解(Junit4.x版本)</h2><pre><code>* @Before：用来修饰方法，该方法会在每一个测试方法执行之前执行一次。
* @After：用来修饰方法，该方法会在每一个测试方法执行之后执行一次。
* @BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前执行一次，而且只执行一次。
* @AfterClass：用来静态修饰方法，该方法会在所有测试方法之后执行一次，而且只执行一次。
</code></pre>
<h2 id="1-3-Junit常用注解-Junit5-x版本"><a href="#1-3-Junit常用注解-Junit5-x版本" class="headerlink" title="1.3 Junit常用注解(Junit5.x版本)"></a>1.3 Junit常用注解(Junit5.x版本)</h2><pre><code> * @BeforeEach：用来修饰方法，该方法会在每一个测试方法执行之前执行一次。
 * @AfterEach：用来修饰方法，该方法会在每一个测试方法执行之后执行一次。
 * @BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前执行一次。
 * @AfterAll：用来静态修饰方法，该方法会在所有测试方法之后执行一次。
</code></pre>
<ul>
<li>示例代码(JUnit4.x)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 业务类：实现加减乘除运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cacluate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     业务方法1：求a和b之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a + b + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     业务方法2:求a和b之差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCacluate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Cacluate c = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span> <span class="comment">// 用来静态修饰方法，该方法会在所有测试方法之前执行一次。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化操作&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Cacluate对象</span></span><br><span class="line">        c = <span class="keyword">new</span> Cacluate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span> <span class="comment">// 用来静态修饰方法，该方法会在所有测试方法之后执行一次。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;释放资源&quot;</span>);</span><br><span class="line">        c = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* @Before // 用来修饰方法，该方法会在每一个测试方法执行之前执行一次。</span></span><br><span class="line"><span class="comment">    public void init()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;初始化操作&quot;);</span></span><br><span class="line"><span class="comment">        // 创建Cacluate对象</span></span><br><span class="line"><span class="comment">        c = new Cacluate();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @After // 用来修饰方法，该方法会在每一个测试方法执行之后执行一次。</span></span><br><span class="line"><span class="comment">    public void close()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;释放资源&quot;);</span></span><br><span class="line"><span class="comment">        c = null;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = c.sum(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            断言：预习判断某个条件一定成立，如果条件不成立，则直接奔溃。</span></span><br><span class="line"><span class="comment">            assertEquals方法的参数</span></span><br><span class="line"><span class="comment">            (String message, double expected, double actual)</span></span><br><span class="line"><span class="comment">            message： 消息字符串</span></span><br><span class="line"><span class="comment">            expected: 期望值</span></span><br><span class="line"><span class="comment">            actual: 实际值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 如果期望值和实际值一致，则什么也不发生，否则会直接奔溃。</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;期望值和实际值不一致&quot;</span>,<span class="number">12</span>,result);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 创建Cacluate对象</span></span><br><span class="line">        <span class="comment">// Cacluate c = new Cacluate();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = c.sub(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果期望值和实际值一致，则什么也不发生，否则会直接奔溃。</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;期望值和实际值不一致&quot;</span>,<span class="number">0</span>,result);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第二章-NIO"><a href="#第二章-NIO" class="headerlink" title="第二章 NIO"></a>第二章 NIO</h1><h2 id="2-1-NIO概述"><a href="#2-1-NIO概述" class="headerlink" title="2.1 NIO概述"></a>2.1 NIO概述</h2><h3 id="1-1-1-NIO引入"><a href="#1-1-1-NIO引入" class="headerlink" title="1.1.1  NIO引入"></a>1.1.1  NIO引入</h3><p>在我们学习Java的NIO流之前，我们都要了解几个关键词</p>
<ul>
<li>同步与异步（synchronous/asynchronous）：<strong>同步</strong>是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；而<strong>异步</strong>则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系</li>
<li>阻塞与非阻塞：在进行<strong>阻塞</strong>操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如ServerSocket新连接建立完毕，或者数据读取、写入操作完成；而<strong>非阻塞</strong>则是不管IO操作是否结束，直接返回，相应操作在后台继续处理</li>
</ul>
<p>在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块的方式处理数据，每一个操作在一步中产生或者消费一个数据，按块处理要比按字节处理数据快的多。</p>
<p>在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<p><strong>NIO之所以是同步，是因为它的accept/read/write方法的内核I/O操作都会阻塞当前线程</strong></p>
<p>首先，我们要先了解一下NIO的三个主要组成部分：Buffer（缓冲区）、Channel（通道）、Selector（选择器）</p>
<h1 id="第三章-Buffer类（缓冲区）"><a href="#第三章-Buffer类（缓冲区）" class="headerlink" title="第三章 Buffer类（缓冲区）"></a>第三章 Buffer类（缓冲区）</h1><h2 id="3-1-Buffer概述"><a href="#3-1-Buffer概述" class="headerlink" title="3.1 Buffer概述"></a>3.1 Buffer概述</h2><p>​        Buffer是一个对象，它对某种基本类型的数组进行了封装。NIO开始使用的Channel(通道)就是通过 Buffer 来读写数据的。</p>
<p>​        在NIO中，所有的数据都是用Buffer处理的，它是NIO读写数据的中转池。Buffer实质上是一个数组，通常是一个字节数据，但也可以是其他类型的数组。但一个缓冲区不仅仅是一个数组，重要的是它提供了对数据的结构化访问，而且还可以跟踪系统的读写进程。</p>
<p>使用 Buffer 读写数据一般遵循以下四个步骤：</p>
<p>1.写入数据到 Buffer；</p>
<p>2.调用 flip() 方法；</p>
<p>3.从 Buffer 中读取数据；</p>
<p>4.调用 clear() 方法或者 compact() 方法。</p>
<p>当向 Buffer 写入数据时，Buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 Buffer 的所有数据。</p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<p>Buffer主要有如下几种：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<h2 id="3-2-创建ByteBuffer"><a href="#3-2-创建ByteBuffer" class="headerlink" title="3.2 创建ByteBuffer"></a>3.2 创建ByteBuffer</h2><ul>
<li><p>ByteBuffer类内部封装了一个byte[]数组，并可以通过一些方法对这个数组进行操作。</p>
</li>
<li><p>创建ByteBuffer对象</p>
<ul>
<li><p>方式一：在堆中创建缓冲区：allocate(int capacity)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//创建堆缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/17.png"></p>
</li>
<li><p>在系统内存创建缓冲区：allocatDirect(int capacity)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//创建直接缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在堆中创建缓冲区称为：间接缓冲区</li>
<li>在系统内存创建缓冲区称为：直接缓冲区</li>
</ul>
</li>
<li><p>间接缓冲区的创建和销毁效率要高于直接缓冲区</p>
<ul>
<li>间接缓冲区的工作效率要低于直接缓冲区</li>
</ul>
</li>
<li><p>方式三：通过数组创建缓冲区：wrap(byte[] arr)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此种方式创建的缓冲区为：间接缓冲区</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-3-向ByteBuffer添加数据"><a href="#3-3-向ByteBuffer添加数据" class="headerlink" title="3.3 向ByteBuffer添加数据"></a>3.3 向ByteBuffer添加数据</h2><ul>
<li><p>public ByteBuffer put(byte b)：向当前可用位置添加数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">10</span>);</span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><img src="C:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/18.png"></p>
</li>
<li><p>public ByteBuffer put(byte[] byteArray)：向当前可用位置添加一个byte[]数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">10</span>);</span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] byteArray = &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    buf.put(byteArray);<span class="comment">//添加整个数组</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><img src="C:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/19.png"></p>
</li>
<li><p>public ByteBuffer put(byte[] byteArray,int offset,int len)：添加一个byte[]数组的一部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">10</span>);</span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] byteArray = &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    buf.put(byteArray,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//只添加byteArray的前两个元素</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    </p>
<h2 id="3-4-容量-capacity"><a href="#3-4-容量-capacity" class="headerlink" title="3.4 容量-capacity"></a>3.4 容量-capacity</h2><ul>
<li><p>Buffer的容量(capacity)是指：Buffer所能够包含的元素的最大数量。定义了Buffer后，容量是不可变的。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer b1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;容量：&quot;</span> + b1.capacity());<span class="comment">//10。之后不可改变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] byteArray = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    ByteBuffer b2 = ByteBuffer.wrap(byteArray);</span><br><span class="line">    System.out.println(<span class="string">&quot;容量：&quot;</span> + b2.capacity());<span class="comment">//4。之后不可改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">容量：<span class="number">10</span></span><br><span class="line">容量：<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-5-限制-limit"><a href="#3-5-限制-limit" class="headerlink" title="3.5 限制-limit"></a>3.5 限制-limit</h2><ul>
<li><p>限制limit是指：第一个不应该读取或写入元素的index索引。缓冲区的限制(limit)不能为负，并且不能大于容量。</p>
</li>
<li><p>有两个相关方法：</p>
<ul>
<li>public int limit()：获取此缓冲区的限制。</li>
<li>public Buffer limit(int newLimit)：设置此缓冲区的限制。</li>
</ul>
</li>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;初始容量：&quot;</span> + buf.capacity() +</span><br><span class="line">                       			<span class="string">&quot; 初始限制：&quot;</span> + buf.limit());<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    buf.limit(<span class="number">3</span>);<span class="comment">//设置限制为：索引3</span></span><br><span class="line">    </span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">10</span>);<span class="comment">//索引：0</span></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">20</span>);<span class="comment">//索引：1</span></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">30</span>);<span class="comment">//索引：2</span></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">40</span>);<span class="comment">//抛出异常</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="C:/%E8%B5%84%E6%96%99/day01-day16%E8%AE%B2%E4%B9%89-V2.0-MD/day13-NIO%E3%80%81AIO/img/10.png"></p>
</li>
</ul>
<h2 id="3-6-位置-position"><a href="#3-6-位置-position" class="headerlink" title="3.6 位置-position"></a>3.6 位置-position</h2><ul>
<li><p>位置position是指：当前可写入的索引。位置不能小于0，并且不能大于”限制”。</p>
</li>
<li><p>有两个相关方法：</p>
<ul>
<li>public int position()：获取当前可写入位置索引。</li>
<li>public Buffer position(int p)：更改当前可写入位置索引。</li>
</ul>
</li>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;初始容量：&quot;</span> + buf.capacity() +</span><br><span class="line">                       <span class="string">&quot; 初始限制：&quot;</span> + buf.limit() +</span><br><span class="line">                       <span class="string">&quot; 当前位置：&quot;</span> + buf.position());<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">10</span>);<span class="comment">//position = 1</span></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">20</span>);<span class="comment">//position = 2</span></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">30</span>);<span class="comment">//position = 3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前容量：&quot;</span> + buf.capacity() +</span><br><span class="line">                       <span class="string">&quot; 初始限制：&quot;</span> + buf.limit() +</span><br><span class="line">                       <span class="string">&quot; 当前位置：&quot;</span> + buf.position());<span class="comment">//3</span></span><br><span class="line">    </span><br><span class="line">    buf.position(<span class="number">1</span>);<span class="comment">//当position改为：1</span></span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">2</span>);<span class="comment">//添加到索引：1</span></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">3</span>);<span class="comment">//添加到索引：2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始容量：<span class="number">10</span> 初始限制：<span class="number">10</span> 当前位置：<span class="number">0</span></span><br><span class="line">初始容量：<span class="number">10</span> 初始限制：<span class="number">10</span> 当前位置：<span class="number">3</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-7-标记-mark"><a href="#3-7-标记-mark" class="headerlink" title="3.7 标记-mark"></a>3.7 标记-mark</h2><ul>
<li><p>标记mark是指：当调用缓冲区的reset()方法时，会将缓冲区的position位置重置为该索引。不能为0，不能大于position。</p>
</li>
<li><p>相关方法：</p>
<ul>
<li>public Buffer mark()：设置此缓冲区的标记为当前的position位置。</li>
</ul>
</li>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;初始容量：&quot;</span> + buf.capacity() +</span><br><span class="line">                       <span class="string">&quot; 初始限制：&quot;</span> + buf.limit() +</span><br><span class="line">                       <span class="string">&quot; 当前位置：&quot;</span> + buf.position());<span class="comment">//初始标记不确定</span></span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">10</span>);</span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">20</span>);</span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">30</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前容量：&quot;</span> + buf.capacity() +</span><br><span class="line">                       <span class="string">&quot; 当前限制：&quot;</span> + buf.limit() +</span><br><span class="line">                       <span class="string">&quot; 当前位置：&quot;</span> + buf.position());</span><br><span class="line">    buf.position(<span class="number">1</span>);<span class="comment">//当position改为：1</span></span><br><span class="line">    buf.mark();<span class="comment">//设置索引1位标记点</span></span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">2</span>);<span class="comment">//添加到索引：1</span></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">3</span>);<span class="comment">//添加到索引：2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前position为：3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将position设置到之前的标记位：1</span></span><br><span class="line">    buf.reset();</span><br><span class="line">    System.out.println(<span class="string">&quot;reset后的当前位置：&quot;</span> + buf.position());</span><br><span class="line"></span><br><span class="line">    buf.put((<span class="keyword">byte</span>) <span class="number">20</span>);<span class="comment">//添加到索引：1</span></span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(buf.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始容量：<span class="number">10</span> 初始限制：<span class="number">10</span> 当前位置：<span class="number">0</span></span><br><span class="line">当前容量：<span class="number">10</span> 当前限制：<span class="number">10</span> 当前位置：<span class="number">3</span></span><br><span class="line">reset后的当前位置：<span class="number">1</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-8-其它方法"><a href="#3-8-其它方法" class="headerlink" title="3.8 其它方法"></a>3.8 其它方法</h2><ul>
<li>public int remaining()：获取position与limit之间的元素数。</li>
<li>public boolean isReadOnly()：获取当前缓冲区是否只读。</li>
<li>public boolean isDirect()：获取当前缓冲区是否为直接缓冲区。</li>
<li>public Buffer clear()：还原缓冲区的状态。<ul>
<li>将position设置为：0</li>
<li>将限制limit设置为容量capacity；</li>
<li>丢弃标记mark。</li>
</ul>
</li>
<li>public Buffer flip()：缩小limit的范围。<ul>
<li>将limit设置为当前position位置；</li>
<li>将当前position位置设置为0；</li>
<li>丢弃标记。</li>
</ul>
</li>
<li>public Buffer rewind()：重绕此缓冲区。<ul>
<li>将position位置设置为：0</li>
<li>限制limit不变。</li>
<li>丢弃标记。</li>
</ul>
</li>
</ul>
<h1 id="第四章-Channel（通道）"><a href="#第四章-Channel（通道）" class="headerlink" title="第四章 Channel（通道）"></a>第四章 Channel（通道）</h1><h2 id="4-1-Channel概述"><a href="#4-1-Channel概述" class="headerlink" title="4.1 Channel概述"></a>4.1 Channel概述</h2><p>Channel（通道）：Channel是一个对象，可以通过它读取和写入数据。可以把它看做是IO中的流，不同的是：</p>
<ul>
<li><p>为所有的原始类型提供（Buffer）缓存支持；</p>
</li>
<li><p>字符集编码解决方案（Charset）；</p>
</li>
<li><p>Channel : 一个新的原始I/O抽象；</p>
</li>
<li><p>支持锁和内存映射文件的文件访问接口；</p>
</li>
<li><p>提供多路（non-bloking）非阻塞式的高伸缩性网路I/O。</p>
</li>
</ul>
<p>正如上面提到的，所有数据都通过Buffer对象处理，所以，您永远不会将字节直接写入到Channel中，相反，您是将数据写入到Buffer中；同样，您也不会从Channel中读取字节，而是将数据从Channel读入Buffer，再从Buffer获取这个字节。</p>
<p>因为Channel是双向的，所以Channel可以比流更好地反映出底层操作系统的真实情况。特别是在Unix模型中，底层操作系统通常都是双向的。</p>
<p>在Java NIO中的Channel主要有如下几种类型：</p>
<ul>
<li>FileChannel：从文件读取数据的</li>
<li>DatagramChannel：读写UDP网络协议数据</li>
<li>SocketChannel：读写TCP网络协议数据</li>
<li>ServerSocketChannel：可以监听TCP连接</li>
</ul>
<h2 id="4-2-FileChannel类的基本使用"><a href="#4-2-FileChannel类的基本使用" class="headerlink" title="4.2 FileChannel类的基本使用"></a>4.2 FileChannel类的基本使用</h2><ul>
<li><p>java.nio.channels.FileChannel (抽象类)：用于读、写文件的通道。</p>
</li>
<li><p>FileChannel是抽象类，我们可以通过FileInputStream和FileOutputStream的getChannel()方法方便的获取一个它的子类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fi=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(src));</span><br><span class="line">FileOutputStream fo=<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(dst));</span><br><span class="line"><span class="comment">//获得传输通道channel</span></span><br><span class="line">FileChannel inChannel=fi.getChannel();</span><br><span class="line">FileChannel outChannel=fo.getChannel();</span><br></pre></td></tr></table></figure></li>
<li><p>我们将通过CopyFile这个示例让大家体会NIO的操作过程。CopyFile执行三个基本的操作：创建一个Buffer，然后从源文件读取数据到缓冲区，然后再将缓冲区写入目标文件。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//声明源文件和目标文件</span></span><br><span class="line">        FileInputStream fi=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\视频.itcast&quot;</span>);</span><br><span class="line">        FileOutputStream fo=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;e:\\视频_copy.itcast&quot;</span>);</span><br><span class="line">        <span class="comment">//获得传输通道channel</span></span><br><span class="line">        FileChannel inChannel=fi.getChannel();</span><br><span class="line">        FileChannel outChannel=fo.getChannel();</span><br><span class="line">        <span class="comment">//获得容器buffer</span></span><br><span class="line">        ByteBuffer buffer= ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> eof = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((eof =inChannel.read(buffer)) != -<span class="number">1</span>)&#123;<span class="comment">//读取的字节将会填充buffer的position到limit位置</span></span><br><span class="line">            <span class="comment">//重设一下buffer：limit=position , position=0</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//开始写</span></span><br><span class="line">            outChannel.write(buffer);<span class="comment">//只输出position到limit之间的数据</span></span><br><span class="line">            <span class="comment">//写完要重置buffer，重设position=0，limit=capacity，用于下次读取</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        inChannel.close();</span><br><span class="line">        outChannel.close();</span><br><span class="line">        fi.close();</span><br><span class="line">        fo.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-FileChannel结合MappedByteBuffer实现高效读写"><a href="#4-3-FileChannel结合MappedByteBuffer实现高效读写" class="headerlink" title="4.3 FileChannel结合MappedByteBuffer实现高效读写"></a>4.3 FileChannel结合MappedByteBuffer实现高效读写</h2><ul>
<li><p>上例直接使用FileChannel结合ByteBuffer实现的管道读写，但并不能提高文件的读写效率。</p>
</li>
<li><p>ByteBuffer有个子类：MappedByteBuffer，它可以创建一个“直接缓冲区”，并可以将文件直接映射至内存，可以提高大文件的读写效率。</p>
<ul>
<li><p>ByteBuffer(抽象类)</p>
<p>​        |–MappedByteBuffer(抽象类)</p>
</li>
</ul>
</li>
<li><p>可以调用FileChannel的map()方法获取一个MappedByteBuffer，map()方法的原型：</p>
<p>​        <strong>MappedByteBuffer map(MapMode mode, long position, long size);</strong> </p>
<p>​        <em>说明：将节点中从position开始的size个字节映射到返回的MappedByteBuffer中。</em></p>
</li>
<li><p><strong>示例：复制2GB以下的文件</strong></p>
<ul>
<li>复制d:\b.rar文件，此文件大概600多兆，复制完毕用时不到2秒。此例不能复制大于2G的文件，因为map的第三个参数被限制在Integer.MAX_VALUE(字节) = 2G。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//java.io.RandomAccessFile类，可以设置读、写模式的IO流类。</span></span><br><span class="line">            <span class="comment">//&quot;r&quot;表示：只读--输入流，只读就可以。</span></span><br><span class="line">            RandomAccessFile source = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\b.rar&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            <span class="comment">//&quot;rw&quot;表示：读、写--输出流，需要读、写。</span></span><br><span class="line">            RandomAccessFile target = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;e:\\b.rar&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            <span class="comment">//分别获取FileChannel通道</span></span><br><span class="line">            FileChannel in = source.getChannel();</span><br><span class="line">            FileChannel out = target.getChannel();</span><br><span class="line">            <span class="comment">//获取文件大小</span></span><br><span class="line">            <span class="keyword">long</span> size = in.size();</span><br><span class="line">            <span class="comment">//调用Channel的map方法获取MappedByteBuffer</span></span><br><span class="line">            MappedByteBuffer mbbi = in.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, size);</span><br><span class="line">            MappedByteBuffer mbbo = out.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, size);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span> b = mbbi.get(i);<span class="comment">//读取一个字节</span></span><br><span class="line">                mbbo.put(i, b);<span class="comment">//将字节添加到mbbo中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;用时: &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">            source.close();</span><br><span class="line">            target.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>代码说明：</p>
</li>
<li><p>map()方法的第一个参数mode：映射的三种模式，在这三种模式下得到的将是三种不同的MappedByteBuffer：三种模式都是Channel的内部类MapMode中定义的静态常量，这里以FileChannel举例：<br>1). <strong>FileChannel.MapMode.READ_ONLY</strong>：得到的镜像只能读不能写（只能使用get之类的读取Buffer中的内容）；</p>
<p>2). <strong>FileChannel.MapMode.READ_WRITE</strong>：得到的镜像可读可写（既然可写了必然可读），对其写会直接更改到存储节点；</p>
<p>3). <strong>FileChannel.MapMode.PRIVATE</strong>：得到一个私有的镜像，其实就是一个(position, size)区域的副本罢了，也是可读可写，只不过写不会影响到存储节点，就是一个普通的ByteBuffer了！！</p>
</li>
<li><p>为什么使用RandomAccessFile？</p>
<p>1). 使用InputStream获得的Channel可以映射，使用map时只能指定为READ_ONLY模式，不能指定为READ_WRITE和PRIVATE，否则会抛出运行时异常！</p>
<p>2). 使用OutputStream得到的Channel不可以映射！并且OutputStream的Channel也只能write不能read！</p>
<p>3). 只有RandomAccessFile获取的Channel才能开启任意的这三种模式！</p>
</li>
</ul>
</li>
<li><p><strong>示例：复制2GB以上文件</strong></p>
<ul>
<li>下例使用循环，将文件分块，可以高效的复制大于2G的文件：要复制的文件为：d:\测试13G.rar，此文件13G多，复制完成大概30秒左右。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.nio.ch.FileChannelImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile source = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;d:\\测试13G.rar&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">            RandomAccessFile target = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;e:\\测试13G.rar&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            FileChannel in = source.getChannel();</span><br><span class="line">            FileChannel out = target.getChannel();</span><br><span class="line">            <span class="keyword">long</span> size = in.size();<span class="comment">//获取文件大小</span></span><br><span class="line">            <span class="keyword">long</span> count = <span class="number">1</span>;<span class="comment">//存储分的块数，默认初始化为：1</span></span><br><span class="line">            <span class="keyword">long</span> copySize = size;<span class="comment">//每次复制的字节数，默认初始化为：文件大小</span></span><br><span class="line">            <span class="keyword">long</span> everySize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">512</span>;<span class="comment">//每块的大小，初始化为：512M</span></span><br><span class="line">            <span class="keyword">if</span>(size &gt; everySize)&#123;<span class="comment">//判断文件是否大于每块的大小</span></span><br><span class="line">                <span class="comment">//判断&quot;文件大小&quot;和&quot;每块大小&quot;是否整除，来计算&quot;块数&quot;</span></span><br><span class="line">                count = (<span class="keyword">int</span>)(size % everySize != <span class="number">0</span> ? size / everySize + <span class="number">1</span> : size / everySize);</span><br><span class="line">                <span class="comment">//第一次复制的大小等于每块大小。</span></span><br><span class="line">                copySize = everySize;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            MappedByteBuffer mbbi = <span class="keyword">null</span>;<span class="comment">//输入的MappedByteBuffer</span></span><br><span class="line">            MappedByteBuffer mbbo = <span class="keyword">null</span>;<span class="comment">//输出的MappedByteBuffer</span></span><br><span class="line">            <span class="keyword">long</span> startIndex = <span class="number">0</span>;<span class="comment">//记录复制每块时的起始位置</span></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                mbbi = in.map(FileChannel.MapMode.READ_ONLY,startIndex,copySize);</span><br><span class="line">                mbbo = out.map(FileChannel.MapMode.READ_WRITE, startIndex,copySize);</span><br><span class="line">         </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; copySize; j++) &#123;</span><br><span class="line">                    <span class="keyword">byte</span> b = mbbi.get(i);</span><br><span class="line">                    mbbo.put(i, b);</span><br><span class="line">                &#125;</span><br><span class="line">                startIndex += copySize;<span class="comment">//计算下一块的起始位置</span></span><br><span class="line">                <span class="comment">//计算下一块要复制的字节数量。</span></span><br><span class="line">                copySize = in.size() - startIndex &gt; everySize ? everySize : in.size() - startIndex;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            source.close();</span><br><span class="line">            target.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;用时: &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-4-ServerSocketChannel和SocketChannel创建连接"><a href="#4-4-ServerSocketChannel和SocketChannel创建连接" class="headerlink" title="4.4 ServerSocketChannel和SocketChannel创建连接"></a>4.4 ServerSocketChannel和SocketChannel创建连接</h2><ul>
<li><p><strong>服务器端：ServerSocketChannel</strong>类用于连接的服务器端，它相当于：ServerSocket。</p>
<p>1). 调用ServerSocketChannel的静态方法open()：打开一个通道，新频道的套接字最初未绑定; 必须通过其套接字的bind方法将其绑定到特定地址，才能接受连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  2). 调用ServerSocketChannel的实例方法bind(SocketAddress add)：绑定本机监听端口，准备接受连接。</p>
<p>  ​      注：java.net.SocketAddress(抽象类)：代表一个Socket地址。</p>
<p>  ​              我们可以使用它的子类：java.net.InetSocketAddress(类)</p>
<p>  ​              构造方法：InetSocketAddress(int port)：指定本机监听端口。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br></pre></td></tr></table></figure>



<p>  3). 调用ServerSocketChannel的实例方法accept()：等待连接。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel accept = serverChannel.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;后续代码...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  示例：服务器端等待连接(默认-阻塞模式)</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open()) &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;【服务器】等待客户端连接...&quot;</span>);</span><br><span class="line">            SocketChannel accept = serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;后续代码......&quot;</span>);</span><br><span class="line">            ......</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行后结果：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【服务器】等待客户端连接...</span><br></pre></td></tr></table></figure>

<p>  <strong>我们可以通过ServerSocketChannel的configureBlocking(boolean b)方法设置accept()是否阻塞</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open()) &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;【服务器】等待客户端连接...&quot;</span>);</span><br><span class="line">       <span class="comment">//   serverChannel.configureBlocking(true);//默认--阻塞</span></span><br><span class="line">            serverChannel.configureBlocking(<span class="keyword">false</span>);<span class="comment">//非阻塞</span></span><br><span class="line">            SocketChannel accept = serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;后续代码......&quot;</span>);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行后结果：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【服务器】等待客户端连接...</span><br><span class="line">后续代码......</span><br></pre></td></tr></table></figure>

<p>  可以看到，accept()方法并没有阻塞，而是直接执行后续代码，返回值为null。</p>
<p>  这种非阻塞的方式，通常用于”客户端”先启动，”服务器端”后启动，来查看是否有客户端连接，有，则接受连接；没有，则继续工作。</p>
<ul>
<li><p><strong>客户端：SocketChannel</strong>类用于连接的客户端，它相当于：Socket。</p>
<p>1). 先调用SocketChannel的open()方法打开通道：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  2). 调用SocketChannel的实例方法connect(SocketAddress add)连接服务器：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br></pre></td></tr></table></figure>



<p>  示例：客户端连接服务器：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel socket = SocketChannel.open()) &#123;</span><br><span class="line">            socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">			System.out.println(<span class="string">&quot;后续代码......&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-5-ServerSocketChannel和SocketChannel收发信息"><a href="#4-5-ServerSocketChannel和SocketChannel收发信息" class="headerlink" title="4.5 ServerSocketChannel和SocketChannel收发信息"></a>4.5 ServerSocketChannel和SocketChannel收发信息</h2><p>接下来我们看一下客户端和服务器端实现信息交互的过程。</p>
<ul>
<li><p>创建服务器端如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel serverChannel = ServerSocketChannel.open()) &#123;</span><br><span class="line">            serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;【服务器】等待客户端连接...&quot;</span>);</span><br><span class="line">            SocketChannel accept = serverChannel.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;【服务器】有连接到达...&quot;</span>);</span><br><span class="line">            <span class="comment">//1.先发一条</span></span><br><span class="line">            ByteBuffer outBuffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            outBuffer.put(<span class="string">&quot;你好客户端，我是服务器&quot;</span>.getBytes());</span><br><span class="line">            outBuffer.flip();<span class="comment">//limit设置为position,position设置为0</span></span><br><span class="line">            accept.write(outBuffer);<span class="comment">//输出从position到limit之间的数据</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.再收一条，不确定字数是多少，但最多是100字节。先准备100字节空间</span></span><br><span class="line">            ByteBuffer inBuffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            accept.read(inBuffer);</span><br><span class="line">            inBuffer.flip();<span class="comment">//limit设置为position,position设置为0</span></span><br><span class="line">            String msg = <span class="keyword">new</span> String(inBuffer.array(),<span class="number">0</span>,inBuffer.limit());</span><br><span class="line">            System.out.println(<span class="string">&quot;【服务器】收到信息：&quot;</span> + msg);</span><br><span class="line">            accept.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建客户端如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel socket = SocketChannel.open()) &#123;</span><br><span class="line">            socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1.先发一条</span></span><br><span class="line">            ByteBuffer buf = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            buf.put(<span class="string">&quot;你好服务器，我是客户端&quot;</span>.getBytes());</span><br><span class="line">            buf.flip();<span class="comment">//limit设置为position,position设置为0</span></span><br><span class="line">            socket.write(buf);<span class="comment">//输出从position到limit之间的数据</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.再收一条，不确定字数是多少，但最多是100字节。先准备100字节空间</span></span><br><span class="line">            ByteBuffer inBuffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            socket.read(inBuffer);</span><br><span class="line">            inBuffer.flip();<span class="comment">//limit设置为position,position设置为0</span></span><br><span class="line">            String msg = <span class="keyword">new</span> String(inBuffer.array(),<span class="number">0</span>,inBuffer.limit());</span><br><span class="line">            System.out.println(<span class="string">&quot;【客户端】收到信息：&quot;</span> + msg);</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>服务器端打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【服务器】等待客户端连接...</span><br><span class="line">【服务器】有连接到达...</span><br><span class="line">【服务器】收到信息：你好服务器，我是客户端</span><br></pre></td></tr></table></figure></li>
<li><p>客户端打印结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【客户端】收到信息：你好客户端，我是服务器</span><br><span class="line">客户端完毕！</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/14/day18%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/day18%E3%80%90Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/14/day21%E5%8F%8D%E5%B0%84&%E6%B3%A8%E8%A7%A3/day21%E3%80%90%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3%E3%80%91/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#day19%E3%80%90Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81NIO%E3%80%91"><span class="nav-number">1.</span> <span class="nav-text">day19【Junit单元测试、NIO】</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8A%E6%97%A5%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.</span> <span class="nav-text">今日内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%99%E5%AD%A6%E7%9B%AE%E6%A0%87"><span class="nav-number">1.2.</span> <span class="nav-text">教学目标</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">2.</span> <span class="nav-text">第一章 Junit单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFJunit"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 什么是Junit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Junit%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-Junit4-x%E7%89%88%E6%9C%AC"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 Junit常用注解(Junit4.x版本)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Junit%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-Junit5-x%E7%89%88%E6%9C%AC"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 Junit常用注解(Junit5.x版本)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-NIO"><span class="nav-number">3.</span> <span class="nav-text">第二章 NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-NIO%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 NIO概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-NIO%E5%BC%95%E5%85%A5"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1.1  NIO引入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Buffer%E7%B1%BB%EF%BC%88%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">第三章 Buffer类（缓冲区）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Buffer%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 Buffer概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%88%9B%E5%BB%BAByteBuffer"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 创建ByteBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%90%91ByteBuffer%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 向ByteBuffer添加数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%AE%B9%E9%87%8F-capacity"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 容量-capacity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E9%99%90%E5%88%B6-limit"><span class="nav-number">4.5.</span> <span class="nav-text">3.5 限制-limit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E4%BD%8D%E7%BD%AE-position"><span class="nav-number">4.6.</span> <span class="nav-text">3.6 位置-position</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E6%A0%87%E8%AE%B0-mark"><span class="nav-number">4.7.</span> <span class="nav-text">3.7 标记-mark</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="nav-number">4.8.</span> <span class="nav-text">3.8 其它方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">第四章 Channel（通道）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Channel%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 Channel概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-FileChannel%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 FileChannel类的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-FileChannel%E7%BB%93%E5%90%88MappedByteBuffer%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 FileChannel结合MappedByteBuffer实现高效读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-ServerSocketChannel%E5%92%8CSocketChannel%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 ServerSocketChannel和SocketChannel创建连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-ServerSocketChannel%E5%92%8CSocketChannel%E6%94%B6%E5%8F%91%E4%BF%A1%E6%81%AF"><span class="nav-number">5.5.</span> <span class="nav-text">4.5 ServerSocketChannel和SocketChannel收发信息</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dara Yoon"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dara Yoon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Eniac286" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Eniac286" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yoondara6@gmail.com" title="E-Mail → mailto:yoondara6@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/user123456" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;user123456" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">

    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eniac286</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
