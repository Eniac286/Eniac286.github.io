<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/2021/03/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Alt+Enter</td>
<td>导入包，错误修复</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>复制当前行</td>
</tr>
<tr>
<td>Ctrl+Alt+L（自定义：Alt+F）</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+/</td>
<td>单行注释</td>
</tr>
<tr>
<td>Ctrl+Shift+/</td>
<td>多行注释</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>自动生成代码，get，set方法</td>
</tr>
<tr>
<td>ALt+Shift+上下箭头</td>
<td>移动当前代码行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE重点</title>
    <url>/2021/04/14/JavaSE%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h5 id="1-error-和-exception-有啥区别"><a href="#1-error-和-exception-有啥区别" class="headerlink" title="1.error 和 exception 有啥区别"></a>1.error 和 exception 有啥区别</h5><h5 id="2-hash-扩容"><a href="#2-hash-扩容" class="headerlink" title="2.hash 扩容"></a>2.hash 扩容</h5><span id="more"></span>

<hr>
<h5 id="3-Java-和-JavaScript-有啥区别"><a href="#3-Java-和-JavaScript-有啥区别" class="headerlink" title="3.Java 和 JavaScript 有啥区别"></a>3.Java 和 JavaScript 有啥区别</h5><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html</a></p>
</blockquote>
<ul>
<li><p>它们的相同之处包括：</p>
<ul>
<li>它们的语法和 C 语言都很相似；</li>
<li>它们都是面向对象的（虽然实现的方式略有不同）；</li>
<li>JavaScript 在设计时参照了 Java 的命名规则；   </li>
</ul>
</li>
<li><p>它们的不同之处包括：</p>
<ul>
<li> JavaScript 是动态类型语言，而 Java 是静态类型语言；</li>
<li>JavaScript 是弱类型的，Java 属于强类型；</li>
<li>JavaScript 的面向对象是基于原型的（prototype-based）实现的，Java 是基于类（class-based）的；</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-final，finally，finalized-的区别"><a href="#4-final，finally，finalized-的区别" class="headerlink" title="4.final，finally，finalized 的区别"></a>4.final，finally，finalized 的区别</h5><h5 id="5-final的特点及应用"><a href="#5-final的特点及应用" class="headerlink" title="5.final的特点及应用"></a>5.final的特点及应用</h5><p>final可以修饰类/方法/局部变量/成员变量</p>
<ul>
<li><p>对于类来说：如果用final修饰，则当前类不能有任何子类，那么其中的所有成员方法都不能覆盖重写</p>
</li>
<li><p>对于方法来说：当用final来修饰方法时，则该方法是最终方法。</p>
</li>
</ul>
<blockquote>
<p>注意：对于类与方法来说，abstract与final不能同时使用。</p>
</blockquote>
<ul>
<li>对于局部变量来说：一次赋值，终身不变。同时，对于基本数据类型来说，不可变说的是数据不变。对于引用类型来说，不可变说的是地址值不变。</li>
<li> 对于成员变量来说：一定要进行手动赋值，要么通过构造方法赋值，要么直接赋值。</li>
</ul>
<hr>
<h5 id="6-修饰符使用范围"><a href="#6-修饰符使用范围" class="headerlink" title="6.修饰符使用范围"></a>6.修饰符使用范围</h5><table>
<thead>
<tr>
<th>关键字</th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>本类当中/我自己</td>
<td>同一个包/我邻居</td>
<td>不同包子类/我儿子</td>
<td>不同包不同类/陌生人</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础--为什么main方法要使用static关键字</title>
    <url>/2021/03/20/Java%E5%9F%BA%E7%A1%80--%E4%B8%BA%E4%BB%80%E4%B9%88main%E6%96%B9%E6%B3%95%E8%A6%81%E4%BD%BF%E7%94%A8static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<ul>
<li>为什么 main 方法是静态的（static）？</li>
<li>为什么main方法是公有的（public） ？</li>
<li>为什么 main 方法没有返回值（Void）？</li>
<li>总结</li>
</ul>
<span id="more"></span>

<hr>
<p>Main 方法是我们学习 Java 编程语言时知道的第一个方法，你是否曾经想过为什么 main 方法是 public、static、void 的。当然，很多人首先学的是 C 和 C++，但是在 Java 中 main 方法与前者有些细微的不同，它不会返回任何值，为什么 main 方式是 public、static、void，这篇文章尝试去找到一些答案。</p>
<p>Main 方法是 Java 程序的入口，记住，我们这里不会讨论 Servlet、MIDlet 和其他任何容器管理的 java 程序，在 java 核心编程中，JVM 会查找类中的 public static void main(String[]args)，如果找不到该方法就抛出错误 NoSuchMethodError:main 程序终止。</p>
<p>Main 方法必须严格遵循它的语法规则，方法签名必须是 public static void，参数是字符串数组类型，如果是 Java1.5 及以后的版本还可以使用可变参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String... args)</span><br></pre></td></tr></table></figure>

<h1 id="为什么-main-方法是静态的（static）？"><a href="#为什么-main-方法是静态的（static）？" class="headerlink" title="为什么 main 方法是静态的（static）？"></a>为什么 main 方法是静态的（static）？</h1><p>1.正因为 main 方法是静态的，JVM 调用这个方法就不需要创建任何包含这个 main 方法的实例。</p>
<p>2.因为 C 和 C++ 同样有类似的 main 方法作为程序执行的入口。</p>
<p>3.如果 main 方法不声明为静态的，JVM 就必须创建 main 类的实例，因为构造器可以被重载，JVM 就没法确定调用哪个 main 方法。</p>
<p>4.静态方法和静态数据加载到内存就可以直接调用而不需要像实例方法一样创建实例后才能调用，如果 main 方法是静态的，那么它就会被加载到 JVM 上下文中成为可执行的方法。</p>
<h1 id="为什么main方法是公有的（public）-？"><a href="#为什么main方法是公有的（public）-？" class="headerlink" title="为什么main方法是公有的（public） ？"></a>为什么main方法是公有的（public） ？</h1><p>Java 指定了一些可访问的修饰符如：private、protected、public，任何方法或变量都可以声明为 public，Java 可以从该类之外的地方访问。因为 main 方法是公共的，JVM 就可以轻松的访问执行它。</p>
<h1 id="为什么-main-方法没有返回值（Void）？"><a href="#为什么-main-方法没有返回值（Void）？" class="headerlink" title="为什么 main 方法没有返回值（Void）？"></a>为什么 main 方法没有返回值（Void）？</h1><p>因为 main 返回任何值对程序都没任何意义，所以设计成 void，意味着 main 不会有任何值返回。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.main 方法必须声明为 public、static、void，否则 JVM 没法运行程序 。</p>
<p>2.如果 JVM 找不到 main 方法就抛出 NoSuchMethodError:main 异常，例如：如果你运行命令：java HelloWrold，JVM 就会在 HelloWorld.class 文件中搜索 public static void main (String[] args) 方法。</p>
<p>3.main 方式是程序的入口，程序执行的开始处。</p>
<p>4.main 方法被一个特定的线程 ”main” 运行，程序会一直运行直到 main 线程结束或者 non-daemon 线程终止。</p>
<p>5.当你看到“Exception in Thread main”如：Excpetion in Thread main:Java.lang.NullPointedException，意味着异常来自于 main 线程。</p>
<p>6.你可以声明 main 方法使用 java1.5 的可变参数的方式如：publicstaticvoid main(String… args)。</p>
<p>7.除了 static、void、和 public，你可以使用 final，synchronized、和 strictfp 修饰符在 main 方法的签名中，如：publicstrictfpfinalsynchronizedstaticvoid main(String[] args)。</p>
<p>8.main 方法在 Java 可以像其他方法一样被重载，但是 JVM 只会调用上面这种签名规范的 main 方法。</p>
<p>9.你可以使用 throws 子句在方法签名中，可以抛出任何 checked 和 unchecked 异常。</p>
<p>10.静态初始化块在 JVM 调用 main 方法前被执行，它们在类被 JVM 加载到内存的时候就被执行了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础--类与对象</title>
    <url>/2021/03/22/Java%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>Java是一门面向对象的高级语言，而类与对象是理解Java编程思想的两个重要要素。对象是对具体事物的抽象，而类是对对象的抽象。</p>
<p>在这里讲一个老套的笑话：</p>
<blockquote>
<p>每个接触的对象都是别人实例化出来的，要想找到对象，你得自己new一个出来。</p>
<p>而我们想要的对象，都是同一类。</p>
</blockquote>
<span id="more"></span>

<h1 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a>什么是类？</h1><p>类是一个抽象的概念的集合，表示一类具有共同属性的事物，所以<strong>类当中应该包含属性和方法</strong>。属性，即事物的特征；方法，即事物能做什么。因此，我们在定义类的时候，以及编写类的成员变量以及类的方法。</p>
<p>基于上述描述，类可以表达基本数据类型，如int、char等表达不了的数据信息。所以，类的特征之一是：<strong>类是对象的数据类型。</strong></p>
<p>实例化对象的一般方法是：</p>
<blockquote>
<p>类 对象=new 类（）;</p>
<p>对比参照：int[]  数组名=new int[]；</p>
</blockquote>
<p>不难看出，类跟数组一样，是一种特殊的数据类型。</p>
<p>因此，从内存空间上来看，对象的具体信息与数组的具体信息一样，存储在堆内存当中，通过new关键字开辟。</p>
<p>从作用域来看，类当中包含内部类和外部类。</p>
<p>而类与类之间的关系，主要包含依赖、关联、聚合、组合、继承、实现。</p>
<hr>
<h1 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h1><p>对象是类的实体，也叫实例化，它具有具体的状态和行为。</p>
<p>对象的组成如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050321287.png" alt="对象的组成"></p>
<p>也就是说，对象包含主要包含：<strong>对象头、实例数据、对齐填充</strong>三部分。</p>
<p>如图所示，对象头中前两行是Mark Word关键字，存储的是类的元数据；第三行是指针，指明类的存储位置。</p>
<p>第四行是实例数据的对象属性，如果该实例数据是数组，还得指明数组长度；</p>
<p>最后一行是对齐填充。</p>
<p>简单来说，对象需要包含<strong>对象头（类名以及类的地址）</strong>、<strong>实例数据（默认值以及长度）</strong>、<strong>对其填充</strong>。</p>
<p>调用对象的一般方式是：对象名.成员方法(   )     /   对象名.成员变量</p>
<hr>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>使用private关键字进行封装，将类的某些信息隐藏在类的内部，不允许外界直接访问。封装的两大优点：提高代码复用性和安全性。</p>
<p>其中，在进行封装时，若全局变量(成员变量)与局部变量重名，使用this关键字指明全局变量。</p>
<p>同时，java提供了get方法和set方法，便于调用类中的成员变量。</p>
<hr>
<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>所谓构造方法就是用来初始化对象的方法，与之相对应的成员方法，即规定对象的行为。</p>
<p>其语法规则包含：方法名与类名一致、无返回值、可以不指定参数。</p>
<p>构造方法的特征包含：提供默认的无参构造、可重载、不可继承、一旦自定义则不再提供默认方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public 方法名( 非必要参数 )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
        <category>基础语法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见命令</title>
    <url>/2021/03/23/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a>常见命令：</h4><p>pwd ： 查看当前路径</p>
<p>ls : 查看当前目录文件夹</p>
<p>mkdir ：创建<strong>文件夹</strong></p>
<p>rm：删除文件</p>
<p>touch：创建<strong>文件</strong></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经</title>
    <url>/2021/04/03/Java%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>最近接到了华东师范大学的复试通知，基于产教融合的模式，去面试了几家公司。</p>
<span id="more"></span>

<h5 id="1-上海软中信息技术有限公司"><a href="#1-上海软中信息技术有限公司" class="headerlink" title="1.上海软中信息技术有限公司"></a>1.上海软中信息技术有限公司</h5><p>考虑到跨专业的原因，没有过多的询问技术经验，一面主要问了各种竞赛经历和项目经历。</p>
<p>Java技术，大概是知道我只恶补了基础部分。</p>
<p>1、问了一下常规的封装、继承、多态等特性。</p>
<p>2、一个算法题，解决思路比较简单：深度优先搜索。细问了回溯的具体实现。</p>
<p>3、问了主要的内排序算法，大概回答梳理了一遍。以为面试官会挑比较难的希尔排序或是快排，没想到只是问了一下冒泡排序，心中狂喜：面试官也太友好了。最好时间复杂度、平均时间复杂度、稳定性，三大必问内容了。</p>
<p>4、问了多线程和输入输出流，还算比较简单，基本没有深入考察。</p>
<p>二面压力面：</p>
<p>1、上来就问，接不接受加班、矛盾冲突怎么解决，好在大学玩过宝洁八大问，加上咸鱼心理，轻松过了。</p>
<p>2、讨价还价，薪资问题，培养模式问题，还有就是要表现出对公司强烈的兴趣和好奇心啦：一个原则–主动主动主动！！！面试官一直设坑，还有什么想问的，并且引导我进行提问，简直变成了对方的提线木偶，被打压的惨不忍睹。</p>
<h5 id="2、Hypers"><a href="#2、Hypers" class="headerlink" title="2、Hypers"></a>2、Hypers</h5><p>暂时只进行了一面，明天先去上海安顿好，6号进行二面：</p>
<p>1、面试官小姐姐也太友好了，居然问返回值？？？以及JDK和JRE是什么？？？由于过于简单，直接把编译工具和运行工具也说了一遍。小姐姐还问了一下编译和运行的过程，好在这个早有准备。</p>
<p>2、问反转字符串，提供了两种解决思路，即栈和循环，小姐姐又深入问了，如何用队列实现栈，勉勉强强算是回答出来了。不过总有种自己坑自己的感觉。</p>
<p>3、后面逐渐加大难度，问了哈希冲突的解决办法以及时间复杂度，中南的初试集中在哈希表的ASL上，这个实在回答的不太好。不过后来还是绕回到同义词的冲突上了，还算扯了一部分。</p>
<p>4、算法部分我给自己挖坑了，谈到了递归、位运算、STL、贪心算法以及动态规划，真的是好后悔呜呜呜。小姐姐直接问动态规划的应用场景！我弱弱地回答没归纳过，大概是类似于背包问题一样的问题？小姐姐狂笑。还好最后举了个爬楼梯的例子，说了一下大概的伪代码，以及解决思路，强行挽尊。</p>
<p>5、最后小姐姐直接让我自己填坑，哪个地方没有回答上来，自己再好好补充。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>问的问题都不难，入门级别，大概是知道我就是个菜鸡吧。也没有特意为难自己，不过Java部分是得好好看看。</p>
<p>几轮下来，发现自己比较擅长的还是算法部分，用算法解决实际问题，这种思考题简直是我的最爱。但是各类算法的应用场景，没有好好归纳过，所以有的时候思考确实会慢很多。</p>
]]></content>
      <categories>
        <category>工作</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora入门技巧</title>
    <url>/2021/03/22/Typora%E5%85%A5%E9%97%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>本篇文章主要就是记录一下MarkDown语法。md语法在所有支持 <code>.md</code> 的软件都是通用的，而快捷键是在<code>Typora</code>软件中适用的。</p>
<ol>
<li><strong>使用  <code>Ctrl+Shift+K</code>创建代码块：</strong> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">右下角 [选择语言]  ：</span><br><span class="line">                  输入 java &#x2F; c++ &#x2F; shell &#x2F; javascript 等任意语言</span><br></pre></td></tr></table></figure>



<span id="more"></span>

<ol start="2">
<li><strong>使用   <code>&gt;</code>   进行引用，效果如下：</strong></li>
</ol>
<blockquote>
<p>   引用内容</p>
</blockquote>
<ol start="3">
<li><strong>使用  <code>#</code> 更改标题大小</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><strong>更改字体格式</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">斜体        *文字内容*</span><br><span class="line">加粗       **文字内容**</span><br><span class="line">删除线      ~~文字内容~~</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <em>斜体</em>            <strong>加粗</strong>             <del>删除线</del></p>
</blockquote>
<ol start="5">
<li><strong>使用 <code>Ctrl+T</code> 建立表格</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + T</td>
<td align="left">新建表格</td>
</tr>
<tr>
<td align="left">双击Enter</td>
<td align="left">清除所有格式，另起一行</td>
</tr>
<tr>
<td align="left">Ctrl+U</td>
<td align="left"><u>下划线</u></td>
</tr>
<tr>
<td align="left">Ctrl+B</td>
<td align="left"><strong>加粗</strong></td>
</tr>
<tr>
<td align="left">Ctrl+I</td>
<td align="left"><em>斜体</em></td>
</tr>
</tbody></table>
<ol start="6">
<li><strong>使用 <code>---</code>进行分割</strong></li>
</ol>
<hr>
<p>创建一条分割线   —</p>
<hr>
<ol start="7">
<li><strong>图片插入</strong>:  <code>Ctrl+Shift+I</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地图片</span></span><br><span class="line">[自定义图片名称]（图片路径）</span><br><span class="line">    </span><br><span class="line">ex: [我的照片]（/images/pic/mine.jpg）</span><br></pre></td></tr></table></figure>



<ol start="8">
<li><strong>超链接</strong>：<code>Ctrl+K</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超链接语法</span></span><br><span class="line"></span><br><span class="line">[我的blog](https:<span class="comment">//eniac286.github.io/)</span></span><br></pre></td></tr></table></figure>

<p>ex： <a href="https://eniac286.github.io/">我的blog</a></p>
<ol start="9">
<li><strong>列表</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无序列表：+ - * 均可创建</span></span><br><span class="line">- 目录<span class="number">1</span></span><br><span class="line">+ 目录<span class="number">2</span></span><br><span class="line">* 目录<span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目录1   </li>
</ul>
<ul>
<li>目录2</li>
<li>目录3</li>
</ul>
<ol start="10">
<li><strong>使用  <code>ctrl+shift+` </code>   创建特殊标记 ：</strong></li>
</ol>
<p>无特殊标记      <code>有特殊标记</code></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java八股文</title>
    <url>/2022/01/19/java%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-面向对象包括哪些特性，如何理解？"><a href="#1-面向对象包括哪些特性，如何理解？" class="headerlink" title="1.面向对象包括哪些特性，如何理解？"></a>1.面向对象包括哪些特性，如何理解？</h3><ul>
<li><p>封装。通过private关键字，将对象的属性和方法封装起来。隐藏一切可隐藏的东西，只对外界提供最简单的编程接口，同时保护了数据。</p>
</li>
<li><p>继承。父类引用指向子类对象，Animal animal = new Cat( ) 即声明的是父类，实际指向的是子类的一个对象。 继承是为了重用父类代码，子类继承父类就拥有了父类的成员。</p>
</li>
<li><p>多态。同一个行为具有不同的表现形式。实现多态需要做两件事：</p>
<p>第一：方法重写（子类继承父类并重写父类中已有的或抽象的方法）</p>
<p>第二：对象造型（用父类引用指向子类对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<span id="more"></span></li>
</ul>
<h3 id="2-Java中异常分为哪些？"><a href="#2-Java中异常分为哪些？" class="headerlink" title="2.Java中异常分为哪些？"></a>2.Java中异常分为哪些？</h3><p>编译异常和运行时异常。</p>
<h3 id="3-error和exception的区别"><a href="#3-error和exception的区别" class="headerlink" title="3.error和exception的区别"></a>3.error和exception的区别</h3><p>父类都是Throwable类，他们的区别如下：</p>
<ul>
<li>Error一般都是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等、</li>
<li>Exception表示程序可以处理的异常，可以捕获且可能恢复。</li>
</ul>
<h3 id="4-请问ArrayList、HashSet、HashMap是线程安全的吗？如果不是，怎么获取安全的集合。"><a href="#4-请问ArrayList、HashSet、HashMap是线程安全的吗？如果不是，怎么获取安全的集合。" class="headerlink" title="4.请问ArrayList、HashSet、HashMap是线程安全的吗？如果不是，怎么获取安全的集合。"></a>4.请问ArrayList、HashSet、HashMap是线程安全的吗？如果不是，怎么获取安全的集合。</h3><p>通过源码进行分析，每个方法都没有加锁，显然都是非线程安全的。在集合中Vector和HashTable是安全的，是因为其核心方法都加上synchronized关键字。Collections工具类中提供上述3个相关的API接口，可以让这些不安全的集合变成安全的。</p>
<h3 id="5-什么是多线程"><a href="#5-什么是多线程" class="headerlink" title="5.什么是多线程?"></a>5.什么是多线程?</h3><p>进程：资源调度和计算的最小单位</p>
<p>线程：资源计算的最小单位</p>
<p>串行：</p>
<p>并发：</p>
<p>并行：</p>
<p>资源往往少于线程数量，需要并发。</p>
<h2 id="二、Spring"><a href="#二、Spring" class="headerlink" title="二、Spring"></a>二、Spring</h2><h3 id="1-SpringMVC的工作原理？"><a href="#1-SpringMVC的工作原理？" class="headerlink" title="1.SpringMVC的工作原理？"></a>1.SpringMVC的工作原理？</h3><ul>
<li>用户向服务器发送请求，通过server.xml文件，请求被前端控制器DispatchServlet捕获；</li>
<li>DispatchServlet对URL进行解析，得到请求资源标识符（URI），通过HandlerMapping找到合适的处理器HandlerExcutionChain;</li>
<li>根据得到的处理器，DispatchServlet选择合适的适配器handlerAdapter处理请求；</li>
<li>handler处理完请求后，返回一个ModelAndView对象给DispatchServlet；</li>
<li>DispatchServlet将此对象通过ViewResolver进行处理，并得到渲染视图；</li>
<li>最后将Model中的参数进行解析，最终呈现出完整的视图返回给客户端；</li>
</ul>
<h3 id="2-常用注解有哪些？"><a href="#2-常用注解有哪些？" class="headerlink" title="2.常用注解有哪些？"></a>2.常用注解有哪些？</h3><h3 id="3-谈谈你对Spring的理解"><a href="#3-谈谈你对Spring的理解" class="headerlink" title="3.谈谈你对Spring的理解"></a>3.谈谈你对Spring的理解</h3><p>Spring是一个开源框架，为简化企业级应用开发而生，Spring是一个IOC和AOP容器框架</p>
<h3 id="4-Spring容器的主要核心是："><a href="#4-Spring容器的主要核心是：" class="headerlink" title="4.Spring容器的主要核心是："></a>4.Spring容器的主要核心是：</h3><h3 id="5-Bean的生命周期"><a href="#5-Bean的生命周期" class="headerlink" title="5.Bean的生命周期"></a>5.Bean的生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050318374.png" alt="Spring的设计模式"></p>
<h2 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h2><h3 id="1-sql注入是什么？-和-的区别是什么"><a href="#1-sql注入是什么？-和-的区别是什么" class="headerlink" title="1.sql注入是什么？#{}和${}的区别是什么?"></a>1.sql注入是什么？#{}和${}的区别是什么?</h3><p>sql注入是指通过web表单输入恶意sql语句，激发数据库漏洞，而不是按设计者意图去执行sql语句。举例：select * from def_user where username=” <u>admin “  or  “a”=”a</u> “恒成立；</p>
<p>#{}是通过预编译处理，如select * from user where username=?,sql语义不会发生改变，在很大程度上可以防止sql注入</p>
<p>${}是字符串替换。在处理时，将 它替换成变量的值，不安全。</p>
<h3 id="2-MySQL性能优化有哪些？"><a href="#2-MySQL性能优化有哪些？" class="headerlink" title="2.MySQL性能优化有哪些？"></a>2.MySQL性能优化有哪些？</h3><ul>
<li>使用limit1</li>
<li>选择正确的数据库引擎</li>
<li>用not exists代替not in</li>
<li>对操作符进行优化，尽量不采用索引的操作符</li>
</ul>
<h2 id="四、Mybatis"><a href="#四、Mybatis" class="headerlink" title="四、Mybatis"></a>四、Mybatis</h2><h3 id="1、什么是-Mybatis？"><a href="#1、什么是-Mybatis？" class="headerlink" title="1、什么是 Mybatis？"></a>1、什么是 Mybatis？</h3><p>（1） Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开<br>发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、<br>创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制<br>sql 执行性能，灵活度高。<br>（2） MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成<br>数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果<br>集。<br>（3） 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通<br>过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql<br>语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。<br>（从执行 sql 到返回 result 的过程）。</p>
<h2 id="五、Redis"><a href="#五、Redis" class="headerlink" title="五、Redis"></a>五、Redis</h2><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050319649.png"></p>
<h2 id="六、RabbitMQ"><a href="#六、RabbitMQ" class="headerlink" title="六、RabbitMQ"></a>六、RabbitMQ</h2><h3 id="1、什么是rabbitmq？"><a href="#1、什么是rabbitmq？" class="headerlink" title="1、什么是rabbitmq？"></a>1、什么是rabbitmq？</h3><p><strong>答：</strong></p>
<p>采用AMQP高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦。</p>
<h3 id="2、为什么要使用rabbitmq？"><a href="#2、为什么要使用rabbitmq？" class="headerlink" title="2、为什么要使用rabbitmq？"></a>2、为什么要使用rabbitmq？</h3><p><strong>答：</strong> 1、在分布式系统下具备异步,削峰,负载均衡等一系列高级功能；</p>
<p>2、拥有持久化的机制，进程消息，队列中的信息也可以保存下来。</p>
<p>3、实现消费者和生产者之间的解耦。</p>
<p>4、对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。</p>
<p>5、可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</p>
<h3 id="4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"><a href="#4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？" class="headerlink" title="4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"></a>4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？</h3><p>答：<br>发送方确认模式<br>1.将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。<br>2.一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。<br>3.如果 RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（notacknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。<br>接收方确认机制<br>接收方消息确认机制<br>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。保证数据的最终一致性；</p>
<h3 id="5-如何避免消息重复投递或重复消费？"><a href="#5-如何避免消息重复投递或重复消费？" class="headerlink" title="5.如何避免消息重复投递或重复消费？"></a>5.如何避免消息重复投递或重复消费？</h3><p><strong>答：</strong></p>
<p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；</p>
<p>在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID 等）作为去重的依据，避免同一条消息被重复消费。</p>
<h3 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6.死信队列"></a>6.死信队列</h3><p>一个消息是有死亡状态的，它会被发送到一个指定的队列中，这个队列是一个普通的队列，根据他的功能，我们叫他死信队列。</p>
<h3 id="8、消息怎么路由？"><a href="#8、消息怎么路由？" class="headerlink" title="8、消息怎么路由？"></a>8、消息怎么路由？</h3><p>答：<br>消息提供方-&gt;路由-&gt;一至多个队列<br>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。<br>通过队列路由键，可以把队列绑定到交换器上。<br>消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；<br>常用的交换器主要分为一下三种<br>1.fanout：如果交换器收到消息，将会广播到所有绑定的队列上<br>2.direct：如果路由键完全匹配，消息就被投递到相应的队列<br>3.topic：可以使来自不同源头的消息能够到达同一个队列。 使用topic交换器时，可以使用通配符</p>
<h3 id="七、ehcache"><a href="#七、ehcache" class="headerlink" title="七、ehcache"></a>七、ehcache</h3><p>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。</p>
<p>Spring Cache 是 Spring 提供的一整套的缓存解决方案。虽然它本身并没有提供缓存的实现，但是它提供了一整套的接口和代码规范、配置、注解等，这样它就可以整合各种缓存方案了，比如 Redis、Ehcache，我们也就不用关心操作缓存的细节。</p>
<p>Spring 提供了四个注解来声明缓存规则。@Cacheable，@CachePut，@CacheEvict，@Caching。</p>
<h3 id="八、简历说明"><a href="#八、简历说明" class="headerlink" title="八、简历说明"></a>八、简历说明</h3><p>独立的模块设计+使用count判断是否存在，改为limit 1</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影笔记</title>
    <url>/2022/02/04/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="01-了解数码相机"><a href="#01-了解数码相机" class="headerlink" title="01 了解数码相机"></a>01 了解数码相机</h2><h3 id="第1节-数码相机机身简介"><a href="#第1节-数码相机机身简介" class="headerlink" title="第1节 数码相机机身简介"></a>第1节 数码相机机身简介</h3><p><strong>单反相机</strong>工作时，光通过镜头进入机身，光线一分为二，一束光在反光镜上通过对焦机构进入五棱镜，之后再通过五棱镜到目镜里。通过光学取景器，可以取景、构图、对焦。另一束光传递到感应器，用于识别场景、测光和设定白平衡。按下快门时，反光镜抬起，快门帘打开，全部光线落在电子感光器上，被影像处理器处理后传输到储存卡中记录下来。</p>
<span id="more"></span>

<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050340856.png" alt="image-20220205034025473" style="zoom:50%;" />

<p><strong>无反相机</strong>工作时，光线通过镜头落在电子感光元件上，被影像处理器处理后传输到储存卡中记录下来。与单反相机不同的是取景方式，无反相机没有反光镜，所以取景也是通过电子感光元件——传感器取景，图像最终呈现在电子取景器（EVF）或者液晶屏上，这一点就好像数码单反相机使用实时取景一样。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050342083.png" alt="image-20220205034254951" style="zoom:50%;" />



<p><strong>传感器尺寸</strong>，又被称为画幅。1934年，柯达公司引入了一次性的胶卷盒，称为135胶卷，1表示一次性，35表示采用了35mm电影胶片。在刚刚进入数码时代的时候，相机厂商们都想做拥有35mm胶片大小传感器的单反相机，这个尺寸被大家称为<strong>35mm全画幅</strong>。</p>
<p>但是大家都遇到一个问题——贵！一旦采用，相机就没几个人能买得起了。从此单反相机中就有了两大传感器尺寸标准——全画幅和APS-C尺寸(23.5mm×15.6mm)。</p>
<h3 id="第2节-镜头简介"><a href="#第2节-镜头简介" class="headerlink" title="第2节 镜头简介"></a>第2节 镜头简介</h3><blockquote>
<p>佳能的EF 70-200mm f/2.8L IS USM II</p>
</blockquote>
<p>1．镜头种类</p>
<p>EF表示EOS相机卡口的镜头。其他的还有EF-S只适用于佳能APS-C画幅EOS相机的镜头；MP-E放大倍率在1倍以上的微距摄影镜头；TS-E移轴镜头。</p>
<p>2．焦距</p>
<p>70-200mm表示这是一个广角端为70mm，长焦端为200mm的变焦镜头。如果只有一个数值那么就是定焦镜头。</p>
<p>3．最大光圈</p>
<p>f/2.8表示这支镜头全焦段的最大光圈是恒定的2.8。有的镜头会有两个数值，分别表示广角端和长焦端的最大光圈。最大光圈表示在这个焦距的时候你可以使用的光圈最大有多大，如果想缩小光圈，自然也是可以的。</p>
<p>4．特性</p>
<p>L表示佳能的专业级镜头，同时镜头前端也会有红圈。IS表示具有防抖功能。USM表示具有超声波马达。II表示这是这个镜头的第二代产品。</p>
<p><strong>总结：光圈越大，单位时间内镜头的通光能力越强，这支镜头往往也越好</strong></p>
<h2 id="02-焦距与取景"><a href="#02-焦距与取景" class="headerlink" title="02 焦距与取景"></a>02 焦距与取景</h2><p> <strong>鱼眼 &lt; 超广角（28mm以下）&lt; 广角 &lt; 微距 &lt; 长焦 &lt; 超长焦（300mm以上）</strong></p>
<p><strong>24mm和28mm</strong></p>
<p>这就是一个标准的广角焦距，主要就是用来拍摄风景。</p>
<p><strong>35mm</strong></p>
<p>有人说这是大师的焦距，也被称为人文眼。简单地说就是拍摄人文最好的焦距。拍摄人文照片的时候需要主体和背景环境的关系，所以小广角的35mm既能够将背景囊括进来，又能突出人与环境的关系，这是拍摄人文的关键</p>
<p><strong>50mm</strong></p>
<p>这被称为标准镜头，拍摄人文、人像都是很好的，也是大师的焦距。</p>
<p><strong>85mm</strong></p>
<p>这是一个拍摄人像的焦距。能有很好的背景虚化效果，很好的画面裁切能力，还能保持和模特之间适当的交流距离。主要用于模特大头照或者特写。</p>
<p><strong>等效焦距</strong></p>
<p>传感器有大有小，会对这些实际焦距取景范围有截取，造成拍摄的视角与实际焦距原本应该有的视角不相同。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050410367.png" alt="image-20220205041015149" style="zoom:50%;" />



<p>实际上每个不同尺寸的传感器都有一个系数与之相对应，这个系数乘以实际焦距之后，就是等效焦距了。这个系数就叫<strong>镜头转换系数。</strong></p>
<p>全画幅：<strong>1.0</strong>x55mm=55mm</p>
<p>APS-C：<strong>1.5</strong>x55mm=82.5mm</p>
<h2 id="03-影调"><a href="#03-影调" class="headerlink" title="03 影调"></a>03 影调</h2><h3 id="第1节-什么是影调"><a href="#第1节-什么是影调" class="headerlink" title="第1节 什么是影调"></a>第1节 什么是影调</h3><p>那些本身就明亮的物体应该用高调表现；那些本身就黑的物体应该用低调表现。</p>
<p>本身就是高调的物体：雪、白馒头、白衣服、白纸、棉花……</p>
<p>本身就是低调的物体：煤炭、黑色皮鞋、黑色的衣服、夜晚的天空……</p>
<p><strong>大多数照片都是中间调，少数场景需要用高调或者低调来表现。</strong></p>
<h3 id="第2节-影调的量化"><a href="#第2节-影调的量化" class="headerlink" title="第2节 影调的量化"></a>第2节 影调的量化</h3><h4 id="曝光补偿-gt-gt-gt-gt"><a href="#曝光补偿-gt-gt-gt-gt" class="headerlink" title="曝光补偿&gt;&gt;&gt;&gt;"></a><strong>曝光补偿&gt;&gt;&gt;&gt;</strong></h4><p>其实在相机中有一个非常标准的量化体系——<strong>曝光补偿</strong>。</p>
<p>曝光补偿的意思就是，相机给你的曝光就是中间调的，你拍的东西亮呢，就往亮了补偿补偿。你拍的东西暗呢，就往暗了补偿补偿。中间调就不补偿。</p>
<h4 id="测光系统-gt-gt-gt-gt"><a href="#测光系统-gt-gt-gt-gt" class="headerlink" title="测光系统&gt;&gt;&gt;&gt;"></a><strong>测光系统&gt;&gt;&gt;&gt;</strong></h4><p>相机的测光系统主要可以分为三种：</p>
<p><strong>智能测光</strong></p>
<p>每个厂商叫的名称不同，但是一般都是默认项。推荐使用。</p>
<p><strong>中心重点平均测光</strong></p>
<p>就是重点考虑中心主体的曝光，然后加权其他背景的曝光。这曾经是很多人最常用的测光方式。但是后来的评价测光、矩阵测光、多重测光等更智能的方式出来之后，用的人逐渐少了。所以新手们，我觉得这个测光方式学不学都可以。</p>
<p><strong>点测光</strong></p>
<p>就是对画面中的一点测光，这个点一般很小，画面中1%～3%的面积，越高级的相机测光面积越小。在复杂光线环境的时候拍一个姑娘，最重要的就是保证姑娘脸是曝光正常的，所以对这姑娘的脸点测光，这个曝光参数就足够保证姑娘脸是好的。</p>
<h2 id="04-曝光补偿三要素"><a href="#04-曝光补偿三要素" class="headerlink" title="04 曝光补偿三要素"></a>04 曝光补偿三要素</h2><p>照片的影调=光线强度×<strong>光圈×快门×感光度</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050428814.png" alt="image-20220205042848707" style="zoom:50%;" />

<p>如果快门速度不变，光圈开大1挡，同时感光度降低1挡得到的照片的明暗程度是相同的，反之亦然。这就是<strong>互易律</strong>。</p>
<h2 id="05-相机模式"><a href="#05-相机模式" class="headerlink" title="05 相机模式"></a>05 相机模式</h2><p>一般来说摄影师的相机都有以下三种模式：</p>
<p><strong>Av、A挡 光圈优先</strong></p>
<p>摄影师设定影调（曝光补偿）和光圈，相机会自动选择合适的快门速度。</p>
<p><strong>Tv、S挡 快门优先</strong></p>
<p>摄影师设定影调（曝光补偿）和快门，相机会自动选择合适的光圈。</p>
<p><strong>M手动（手动控制光圈、快门）</strong></p>
<p>摄影师设定光圈、快门，相机告诉你影调将会是如何。</p>
<p>使用M挡手动曝光情况都是你无法使用相机测光的时候，其实等于你放弃了相机测光。所以请记住，往往在你无法使用相机测光的时候，才用M挡。</p>
<h2 id="06-光线"><a href="#06-光线" class="headerlink" title="06 光线"></a>06 光线</h2><h3 id="第1节-光线的特性"><a href="#第1节-光线的特性" class="headerlink" title="第1节 光线的特性"></a>第1节 光线的特性</h3><p><strong>顺光</strong></p>
<p>其实顺光不应过多地运用在人像摄影中。因为正面直射的光会消除面部的一切影子，使得面部趋于平面化，所以又叫平光。</p>
<p><strong>侧光</strong></p>
<p>侧光一般用在人物摄影的造型上。相比顺光会将人物拍成“大白脸”，侧光能够让人物的面部呈现立体效果。</p>
<p><strong>逆光</strong></p>
<p>逆光是很多摄影师进行创作的用光。使用逆光拍摄的时候，往往会有雾蒙蒙的感觉，并形成暖色调。</p>
<p><strong>色温</strong></p>
<p>蓝色是冷色，但是色温高；红色是暖色，但是色温低。</p>
<p>日光的色温大概是5500K。白纸放到日光下就是白色的。</p>
<p><strong>白平衡</strong></p>
<p>白平衡是相机机内处理的结果。说白了就是相机自己的后期。所以如果你拍摄RAW格式照片的话，可以在计算机中重新定义白平衡，重新调节。理论上是没有画质损失的（尽管实际可能有，但是也非常小，可忽略）。</p>
<blockquote>
<p>所以AWB+RAW拍摄，是一个既方便，又保险的组合。</p>
</blockquote>
<h3 id="第2节-布光方法"><a href="#第2节-布光方法" class="headerlink" title="第2节 布光方法"></a>第2节 布光方法</h3><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050444659.png" alt="image-20220205044427503" style="zoom:50%;" />

<p><strong>伦勃朗布光法</strong>有几个特点：</p>
<p>1．四分之三面部对着相机。让人物面向相机，缓慢变换角度，直到看不到一侧的耳朵为止。</p>
<p>2．架设主灯，强度要能使人面部正确曝光，方向为与人物面部方向同一侧45°左右。注意，要在人物面部形成三角形光区（以鼻子阴影、面颊阴影、下眼线为边长，围成的三角形亮区）。</p>
<p>3．架设辅灯。将面部阴影处柔化，并表现出细节。一般会使用4:1或者3:1的光比。</p>
<p>4．架设背景灯，打亮背景。如果有可能从人物斜后方放置一束比较集中的光，打在人物轮廓上，形成轮廓光。如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050446673.png" alt="image-20220205044609555" style="zoom:50%;" />



<p>伦勃朗布光法是适用于男性的。那么再提供一个适用于女性摄影的布光法——<strong>蝶形布光法</strong>。</p>
<p><strong>蝶形布光法</strong>的名字来源于布光法中的一个特点。类似于伦勃朗布光法中要找三角形光区，蝶形布光法就是要找这个蝶形。使用蝶形布光法的时候，主灯放置在人物正前方，但是处于比较高的位置。这与顶光不同。蝶形布光法的主灯是从上斜射下来的。这样在人物的鼻子下方就会形成一个阴影。随着主灯高度变化，阴影会在鼻子下面形成一个蝴蝶的形状。这时主灯的位置就可以确定了。</p>
<h2 id="07-摄影中的虚实"><a href="#07-摄影中的虚实" class="headerlink" title="07 摄影中的虚实"></a>07 摄影中的虚实</h2><p><strong>前帘同步闪光</strong>就是：</p>
<p>前帘开启之后（也是曝光的开始），就闪光，闪完了之后等曝光时间一到后帘关闭（曝光结束）。这样就是一辆车移动，你拍摄车。开启快门就闪光了，车被闪光灯定在了画面中，然后长曝光继续曝，车往前走拉车线。这样就变成了车在后面，车线在前面的奇葩照片。</p>
<img src="C:/Users/Yoon/AppData/Roaming/Typora/typora-user-images/image-20220205045502246.png" alt="image-20220205045502246" style="zoom:25%;" />



<p><strong>后帘同步闪光</strong>就是：</p>
<p>前帘开启之后（也是曝光的开始），先踏踏实实曝着光。然后闪光灯闪了一下，定格画面，随即后帘关闭（曝光结束）。这样一辆车移动，你拍摄车。开启快门，先拉车线，然后马上快门关闭了，闪光灯突然把车定格住。就变成了车在前面，车线在后面的好画面了。</p>
<img src="C:/Users/Yoon/AppData/Roaming/Typora/typora-user-images/image-20220205045429391.png" alt="image-20220205045429391" style="zoom:25%;" />

<h2 id="08-构图"><a href="#08-构图" class="headerlink" title="08 构图"></a>08 构图</h2><p><strong>居中构图</strong></p>
<p><strong>三分法构图</strong></p>
<p><strong>重复法</strong></p>
<p><strong>引导线</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050457311.png" alt="image-20220205045729070" style="zoom:25%;" />

<p><strong>三角构图</strong></p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>摘抄--3月24日</title>
    <url>/2021/03/24/%E6%91%98%E6%8A%84--3%E6%9C%8824%E6%97%A5/</url>
    <content><![CDATA[<p>过去的每一天都不曾消失，它们闪烁在未来的天幕上，成为个人的群星，构成属于你自己的浩瀚银河。</p>
<p>然后，在某一刻，哗啦一声，向你奔涌而来。</p>
<p>我相信，每个人心中，都存在对浩瀚的体验。</p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
