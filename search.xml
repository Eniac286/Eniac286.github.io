<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaSE重点</title>
    <url>/2021/04/14/JavaSE%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h5 id="1-error-和-exception-有啥区别"><a href="#1-error-和-exception-有啥区别" class="headerlink" title="1.error 和 exception 有啥区别"></a>1.error 和 exception 有啥区别</h5><h5 id="2-hash-扩容"><a href="#2-hash-扩容" class="headerlink" title="2.hash 扩容"></a>2.hash 扩容</h5><span id="more"></span>

<hr>
<h5 id="3-Java-和-JavaScript-有啥区别"><a href="#3-Java-和-JavaScript-有啥区别" class="headerlink" title="3.Java 和 JavaScript 有啥区别"></a>3.Java 和 JavaScript 有啥区别</h5><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html</a></p>
</blockquote>
<ul>
<li><p>它们的相同之处包括：</p>
<ul>
<li>它们的语法和 C 语言都很相似；</li>
<li>它们都是面向对象的（虽然实现的方式略有不同）；</li>
<li>JavaScript 在设计时参照了 Java 的命名规则；   </li>
</ul>
</li>
<li><p>它们的不同之处包括：</p>
<ul>
<li> JavaScript 是动态类型语言，而 Java 是静态类型语言；</li>
<li>JavaScript 是弱类型的，Java 属于强类型；</li>
<li>JavaScript 的面向对象是基于原型的（prototype-based）实现的，Java 是基于类（class-based）的；</li>
</ul>
</li>
</ul>
<hr>
<h5 id="4-final，finally，finalized-的区别"><a href="#4-final，finally，finalized-的区别" class="headerlink" title="4.final，finally，finalized 的区别"></a>4.final，finally，finalized 的区别</h5><h5 id="5-final的特点及应用"><a href="#5-final的特点及应用" class="headerlink" title="5.final的特点及应用"></a>5.final的特点及应用</h5><p>final可以修饰类/方法/局部变量/成员变量</p>
<ul>
<li><p>对于类来说：如果用final修饰，则当前类不能有任何子类，那么其中的所有成员方法都不能覆盖重写</p>
</li>
<li><p>对于方法来说：当用final来修饰方法时，则该方法是最终方法。</p>
</li>
</ul>
<blockquote>
<p>注意：对于类与方法来说，abstract与final不能同时使用。</p>
</blockquote>
<ul>
<li>对于局部变量来说：一次赋值，终身不变。同时，对于基本数据类型来说，不可变说的是数据不变。对于引用类型来说，不可变说的是地址值不变。</li>
<li> 对于成员变量来说：一定要进行手动赋值，要么通过构造方法赋值，要么直接赋值。</li>
</ul>
<hr>
<h5 id="6-修饰符使用范围"><a href="#6-修饰符使用范围" class="headerlink" title="6.修饰符使用范围"></a>6.修饰符使用范围</h5><table>
<thead>
<tr>
<th>关键字</th>
<th>private</th>
<th>default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>本类当中/我自己</td>
<td>同一个包/我邻居</td>
<td>不同包子类/我儿子</td>
<td>不同包不同类/陌生人</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键</title>
    <url>/2021/03/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Alt+Enter</td>
<td>导入包，错误修复</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>复制当前行</td>
</tr>
<tr>
<td>Ctrl+Alt+L（自定义：Alt+F）</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+/</td>
<td>单行注释</td>
</tr>
<tr>
<td>Ctrl+Shift+/</td>
<td>多行注释</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>自动生成代码，get，set方法</td>
</tr>
<tr>
<td>ALt+Shift+上下箭头</td>
<td>移动当前代码行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见命令</title>
    <url>/2021/03/23/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a>常见命令：</h4><p>pwd ： 查看当前路径</p>
<p>ls : 查看当前目录文件夹</p>
<p>mkdir ：创建<strong>文件夹</strong></p>
<p>rm：删除文件</p>
<p>touch：创建<strong>文件</strong></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Read a Computer Science Research Paper</title>
    <url>/2022/03/19/HowToReadCSPaper/</url>
    <content><![CDATA[<h4 id="Publication-Venues"><a href="#Publication-Venues" class="headerlink" title="Publication Venues"></a>Publication Venues</h4><ul>
<li>General : ACM , IEEE , AAAI , ACL</li>
<li>Specifically Recommended By CCF : <strong><a href="https://www.ccf.org.cn/Academic_Evaluation/By_category/">https://www.ccf.org.cn/Academic_Evaluation/By_category/</a></strong></li>
</ul>
<blockquote>
<p>中国计算机学会（China Computer Federation）</p>
</blockquote>
<h4 id="Different-Types-of-CS-Research-Paper"><a href="#Different-Types-of-CS-Research-Paper" class="headerlink" title="Different Types of CS Research Paper"></a>Different Types of CS Research Paper</h4><p>There are three basic types of CS research paper: <strong>theoretical</strong>, <strong>engineering</strong> and <strong>empirical</strong>.</p>
<ul>
<li>A theoretical paper describes a theory or algorithm or provides a mathematical proof for some hypothesis.</li>
<li>An engineering paper describes an implementation of an algorithm, or part or all of a computer system or application. Engineering papers are now frequently required to include descriptions of system evaluation.</li>
<li>An empirical paper describes an experiment designed to test some hypothesis.</li>
</ul>
<span id="more"></span>



<h4 id="Taxonomy-of-Scientific-Papers"><a href="#Taxonomy-of-Scientific-Papers" class="headerlink" title="Taxonomy of Scientific Papers"></a>Taxonomy of Scientific Papers</h4><ul>
<li><p>Conference Papers</p>
<ul>
<li><p>Review : YES , peer-reviewed , the threshold depends on the conference</p>
</li>
<li><p>Goal : Publish a finished work with possible forthcoming research</p>
</li>
<li><p>Size : 8 - 20 Pages</p>
</li>
</ul>
</li>
<li><p>Journal Papers</p>
<ul>
<li><p>Review : YES , peer-reviewed , more longer than Conference Papers</p>
</li>
<li><p>Goal : Publish a present completed work</p>
</li>
<li><p>Size : 15 Pages</p>
</li>
</ul>
</li>
</ul>
<h4 id="How-call-I-tell-whether-a-research-paper-is-good-before-I-read-it"><a href="#How-call-I-tell-whether-a-research-paper-is-good-before-I-read-it" class="headerlink" title="How call I tell whether a research paper is good before I read it?"></a>How call I tell whether a research paper is good before I read it?</h4><p>Here are some indicators of a good research paper:</p>
<ul>
<li><ol>
<li>The problem the paper addresses is clearly stated, both in the abstract and early on in the paper itself. The technical importance and broader impacts of the paper are described. </li>
</ol>
</li>
<li><ol start="2">
<li>The paper includes a clear description of the experiment, system or theory the problem addresses. This is usually the second section of the paper. </li>
</ol>
</li>
<li><ol start="3">
<li>The paper describes and analyzes the results of the work described (either experimental or evaluation results).</li>
</ol>
</li>
<li><ol start="4">
<li>The authors have some sound, non-trivial ideas for future work. This usually appears at the end of the paper. </li>
</ol>
</li>
<li><ol start="5">
<li>Related work is described and cited correctly. You can get an idea of this by looking at the list of references at the end of the paper. </li>
</ol>
</li>
</ul>
<p>If you know that a researcher has been working in an area for a while, that is usually an indicator that the research is sound; however, do not underestimate the contributions of people new to a field or the impact of politics on research.</p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora入门技巧</title>
    <url>/2021/03/22/Typora%E5%85%A5%E9%97%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>本篇文章主要就是记录一下MarkDown语法。md语法在所有支持 <code>.md</code> 的软件都是通用的，而快捷键是在<code>Typora</code>软件中适用的。</p>
<ol>
<li><strong>使用  <code>Ctrl+Shift+K</code>创建代码块：</strong> </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">右下角 [选择语言]  ：</span><br><span class="line">                  输入 java &#x2F; c++ &#x2F; shell &#x2F; javascript 等任意语言</span><br></pre></td></tr></table></figure>



<span id="more"></span>

<ol start="2">
<li><strong>使用   <code>&gt;</code>   进行引用，效果如下：</strong></li>
</ol>
<blockquote>
<p>   引用内容</p>
</blockquote>
<ol start="3">
<li><strong>使用  <code>#</code> 更改标题大小</strong></li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure>



<ol start="4">
<li><strong>更改字体格式</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">斜体        *文字内容*</span><br><span class="line">加粗       **文字内容**</span><br><span class="line">删除线      ~~文字内容~~</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <em>斜体</em>            <strong>加粗</strong>             <del>删除线</del></p>
</blockquote>
<ol start="5">
<li><strong>使用 <code>Ctrl+T</code> 建立表格</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + T</td>
<td align="left">新建表格</td>
</tr>
<tr>
<td align="left">双击Enter</td>
<td align="left">清除所有格式，另起一行</td>
</tr>
<tr>
<td align="left">Ctrl+U</td>
<td align="left"><u>下划线</u></td>
</tr>
<tr>
<td align="left">Ctrl+B</td>
<td align="left"><strong>加粗</strong></td>
</tr>
<tr>
<td align="left">Ctrl+I</td>
<td align="left"><em>斜体</em></td>
</tr>
</tbody></table>
<ol start="6">
<li><strong>使用 <code>---</code>进行分割</strong></li>
</ol>
<hr>
<p>创建一条分割线   —</p>
<hr>
<ol start="7">
<li><strong>图片插入</strong>:  <code>Ctrl+Shift+I</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本地图片</span></span><br><span class="line">[自定义图片名称]（图片路径）</span><br><span class="line">    </span><br><span class="line">ex: [我的照片]（/images/pic/mine.jpg）</span><br></pre></td></tr></table></figure>



<ol start="8">
<li><strong>超链接</strong>：<code>Ctrl+K</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超链接语法</span></span><br><span class="line"></span><br><span class="line">[我的blog](https:<span class="comment">//eniac286.github.io/)</span></span><br></pre></td></tr></table></figure>

<p>ex： <a href="https://eniac286.github.io/">我的blog</a></p>
<ol start="9">
<li><strong>列表</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无序列表：+ - * 均可创建</span></span><br><span class="line">- 目录<span class="number">1</span></span><br><span class="line">+ 目录<span class="number">2</span></span><br><span class="line">* 目录<span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>目录1   </li>
</ul>
<ul>
<li>目录2</li>
<li>目录3</li>
</ul>
<ol start="10">
<li><strong>使用  <code>ctrl+shift+` </code>   创建特殊标记 ：</strong></li>
</ol>
<p>无特殊标记      <code>有特殊标记</code></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式二三事</title>
    <url>/2022/03/26/java%E5%85%AB%E8%82%A1%E6%96%87-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="一、理解设计模式"><a href="#一、理解设计模式" class="headerlink" title="一、理解设计模式"></a>一、理解设计模式</h2><h3 id="理解设计模式"><a href="#理解设计模式" class="headerlink" title="理解设计模式"></a>理解设计模式</h3><p>设计模式是软件开发人员经过长时间试错和应用总结出来的，解决特定问题的一系列方法。可以迅速提高代码的<strong>可读性、健壮性、扩展性。</strong></p>
<p>参考链接：<a href="https://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html">https://tech.meituan.com/2022/03/10/interesting-talk-about-design-patterns.html</a></p>
<blockquote>
<p><strong>策略模式</strong>定义了一系列的算法，并将每一个算法封装起来，使它们可以相互替换。策略模式通常包含以下角色：</p>
<ul>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>适配器模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>单例模式</strong>：设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<ul>
<li>这种模式涉及到一个单一的类，该类负责创建自己的对象，</li>
<li>同时确保只有单个对象被创建。</li>
<li>这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</li>
</ul>
</blockquote>
<h3 id="七大基本原则（SOLID）："><a href="#七大基本原则（SOLID）：" class="headerlink" title="七大基本原则（SOLID）："></a>七大基本原则（SOLID）：</h3><ol>
<li>单一职责原则 (Single Responsibility Principle)</li>
<li>开放-关闭原则 (Open-Closed Principle)</li>
<li>里氏替换原则 (Liskov Substitution Principle)</li>
<li>依赖倒转原则 (Dependence Inversion Principle)</li>
<li>接口隔离原则 (Interface Segregation Principle)</li>
<li>迪米特法则（Law Of Demeter）</li>
<li>组合/聚合复用原则 (Composite/Aggregate Reuse Principle)</li>
</ol>
<p>参考链接： <a href="https://zhuanlan.zhihu.com/p/24614363">https://zhuanlan.zhihu.com/p/24614363</a></p>
<h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>1、单例类只能有一个实例。</p>
</li>
<li><p>2、单例类必须自己创建自己的唯一实例。</p>
</li>
<li><p>3、单例类必须给所有其他对象提供这一实例。</p>
</li>
</ul>
<p><strong>懒汉式(线程不安全)：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>

<p>**懒汉式(线程安全)**：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> instance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">	 		instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饿汉式(线程不安全):</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">	private static final instance &#x3D; new Singleton();</span><br><span class="line">	private singleton()&#123;&#125;;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双检锁/双重校验锁（DCL，即 double-checked locking）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            synchronize(Singleton.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a>2.代理模式</h3><h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><h3 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4.工厂模式"></a>4.工厂模式</h3><span id="more"></span>]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>摘抄--3月24日</title>
    <url>/2021/03/24/%E6%91%98%E6%8A%84--3%E6%9C%8824%E6%97%A5/</url>
    <content><![CDATA[<p>过去的每一天都不曾消失，它们闪烁在未来的天幕上，成为个人的群星，构成属于你自己的浩瀚银河。</p>
<p>然后，在某一刻，哗啦一声，向你奔涌而来。</p>
<p>我相信，每个人心中，都存在对浩瀚的体验。</p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影笔记</title>
    <url>/2022/02/04/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="01-了解数码相机"><a href="#01-了解数码相机" class="headerlink" title="01 了解数码相机"></a>01 了解数码相机</h2><h3 id="第1节-数码相机机身简介"><a href="#第1节-数码相机机身简介" class="headerlink" title="第1节 数码相机机身简介"></a>第1节 数码相机机身简介</h3><p><strong>单反相机</strong>工作时，光通过镜头进入机身，光线一分为二，一束光在反光镜上通过对焦机构进入五棱镜，之后再通过五棱镜到目镜里。通过光学取景器，可以取景、构图、对焦。另一束光传递到感应器，用于识别场景、测光和设定白平衡。按下快门时，反光镜抬起，快门帘打开，全部光线落在电子感光器上，被影像处理器处理后传输到储存卡中记录下来。</p>
<span id="more"></span>

<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050340856.png" alt="image-20220205034025473" style="zoom:50%;" />

<p><strong>无反相机</strong>工作时，光线通过镜头落在电子感光元件上，被影像处理器处理后传输到储存卡中记录下来。与单反相机不同的是取景方式，无反相机没有反光镜，所以取景也是通过电子感光元件——传感器取景，图像最终呈现在电子取景器（EVF）或者液晶屏上，这一点就好像数码单反相机使用实时取景一样。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050342083.png" alt="image-20220205034254951" style="zoom:50%;" />



<p><strong>传感器尺寸</strong>，又被称为画幅。1934年，柯达公司引入了一次性的胶卷盒，称为135胶卷，1表示一次性，35表示采用了35mm电影胶片。在刚刚进入数码时代的时候，相机厂商们都想做拥有35mm胶片大小传感器的单反相机，这个尺寸被大家称为<strong>35mm全画幅</strong>。</p>
<p>但是大家都遇到一个问题——贵！一旦采用，相机就没几个人能买得起了。从此单反相机中就有了两大传感器尺寸标准——全画幅和APS-C尺寸(23.5mm×15.6mm)。</p>
<h3 id="第2节-镜头简介"><a href="#第2节-镜头简介" class="headerlink" title="第2节 镜头简介"></a>第2节 镜头简介</h3><blockquote>
<p>佳能的EF 70-200mm f/2.8L IS USM II</p>
</blockquote>
<p>1．镜头种类</p>
<p>EF表示EOS相机卡口的镜头。其他的还有EF-S只适用于佳能APS-C画幅EOS相机的镜头；MP-E放大倍率在1倍以上的微距摄影镜头；TS-E移轴镜头。</p>
<p>2．焦距</p>
<p>70-200mm表示这是一个广角端为70mm，长焦端为200mm的变焦镜头。如果只有一个数值那么就是定焦镜头。</p>
<p>3．最大光圈</p>
<p>f/2.8表示这支镜头全焦段的最大光圈是恒定的2.8。有的镜头会有两个数值，分别表示广角端和长焦端的最大光圈。最大光圈表示在这个焦距的时候你可以使用的光圈最大有多大，如果想缩小光圈，自然也是可以的。</p>
<p>4．特性</p>
<p>L表示佳能的专业级镜头，同时镜头前端也会有红圈。IS表示具有防抖功能。USM表示具有超声波马达。II表示这是这个镜头的第二代产品。</p>
<p><strong>总结：光圈越大，单位时间内镜头的通光能力越强，这支镜头往往也越好</strong></p>
<h2 id="02-焦距与取景"><a href="#02-焦距与取景" class="headerlink" title="02 焦距与取景"></a>02 焦距与取景</h2><p> <strong>鱼眼 &lt; 超广角（28mm以下）&lt; 广角 &lt; 微距 &lt; 长焦 &lt; 超长焦（300mm以上）</strong></p>
<p><strong>24mm和28mm</strong></p>
<p>这就是一个标准的广角焦距，主要就是用来拍摄风景。</p>
<p><strong>35mm</strong></p>
<p>有人说这是大师的焦距，也被称为人文眼。简单地说就是拍摄人文最好的焦距。拍摄人文照片的时候需要主体和背景环境的关系，所以小广角的35mm既能够将背景囊括进来，又能突出人与环境的关系，这是拍摄人文的关键</p>
<p><strong>50mm</strong></p>
<p>这被称为标准镜头，拍摄人文、人像都是很好的，也是大师的焦距。</p>
<p><strong>85mm</strong></p>
<p>这是一个拍摄人像的焦距。能有很好的背景虚化效果，很好的画面裁切能力，还能保持和模特之间适当的交流距离。主要用于模特大头照或者特写。</p>
<p><strong>等效焦距</strong></p>
<p>传感器有大有小，会对这些实际焦距取景范围有截取，造成拍摄的视角与实际焦距原本应该有的视角不相同。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050410367.png" alt="image-20220205041015149" style="zoom:50%;" />



<p>实际上每个不同尺寸的传感器都有一个系数与之相对应，这个系数乘以实际焦距之后，就是等效焦距了。这个系数就叫<strong>镜头转换系数。</strong></p>
<p>全画幅：<strong>1.0</strong>x55mm=55mm</p>
<p>APS-C：<strong>1.5</strong>x55mm=82.5mm</p>
<h2 id="03-影调"><a href="#03-影调" class="headerlink" title="03 影调"></a>03 影调</h2><h3 id="第1节-什么是影调"><a href="#第1节-什么是影调" class="headerlink" title="第1节 什么是影调"></a>第1节 什么是影调</h3><p>那些本身就明亮的物体应该用高调表现；那些本身就黑的物体应该用低调表现。</p>
<p>本身就是高调的物体：雪、白馒头、白衣服、白纸、棉花……</p>
<p>本身就是低调的物体：煤炭、黑色皮鞋、黑色的衣服、夜晚的天空……</p>
<p><strong>大多数照片都是中间调，少数场景需要用高调或者低调来表现。</strong></p>
<h3 id="第2节-影调的量化"><a href="#第2节-影调的量化" class="headerlink" title="第2节 影调的量化"></a>第2节 影调的量化</h3><h4 id="曝光补偿-gt-gt-gt-gt"><a href="#曝光补偿-gt-gt-gt-gt" class="headerlink" title="曝光补偿&gt;&gt;&gt;&gt;"></a><strong>曝光补偿&gt;&gt;&gt;&gt;</strong></h4><p>其实在相机中有一个非常标准的量化体系——<strong>曝光补偿</strong>。</p>
<p>曝光补偿的意思就是，相机给你的曝光就是中间调的，你拍的东西亮呢，就往亮了补偿补偿。你拍的东西暗呢，就往暗了补偿补偿。中间调就不补偿。</p>
<h4 id="测光系统-gt-gt-gt-gt"><a href="#测光系统-gt-gt-gt-gt" class="headerlink" title="测光系统&gt;&gt;&gt;&gt;"></a><strong>测光系统&gt;&gt;&gt;&gt;</strong></h4><p>相机的测光系统主要可以分为三种：</p>
<p><strong>智能测光</strong></p>
<p>每个厂商叫的名称不同，但是一般都是默认项。推荐使用。</p>
<p><strong>中心重点平均测光</strong></p>
<p>就是重点考虑中心主体的曝光，然后加权其他背景的曝光。这曾经是很多人最常用的测光方式。但是后来的评价测光、矩阵测光、多重测光等更智能的方式出来之后，用的人逐渐少了。所以新手们，我觉得这个测光方式学不学都可以。</p>
<p><strong>点测光</strong></p>
<p>就是对画面中的一点测光，这个点一般很小，画面中1%～3%的面积，越高级的相机测光面积越小。在复杂光线环境的时候拍一个姑娘，最重要的就是保证姑娘脸是曝光正常的，所以对这姑娘的脸点测光，这个曝光参数就足够保证姑娘脸是好的。</p>
<h2 id="04-曝光补偿三要素"><a href="#04-曝光补偿三要素" class="headerlink" title="04 曝光补偿三要素"></a>04 曝光补偿三要素</h2><p>照片的影调=光线强度×<strong>光圈×快门×感光度</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050428814.png" alt="image-20220205042848707" style="zoom:50%;" />

<p>如果快门速度不变，光圈开大1挡，同时感光度降低1挡得到的照片的明暗程度是相同的，反之亦然。这就是<strong>互易律</strong>。</p>
<h2 id="05-相机模式"><a href="#05-相机模式" class="headerlink" title="05 相机模式"></a>05 相机模式</h2><p>一般来说摄影师的相机都有以下三种模式：</p>
<p><strong>Av、A挡 光圈优先</strong></p>
<p>摄影师设定影调（曝光补偿）和光圈，相机会自动选择合适的快门速度。</p>
<p><strong>Tv、S挡 快门优先</strong></p>
<p>摄影师设定影调（曝光补偿）和快门，相机会自动选择合适的光圈。</p>
<p><strong>M手动（手动控制光圈、快门）</strong></p>
<p>摄影师设定光圈、快门，相机告诉你影调将会是如何。</p>
<p>使用M挡手动曝光情况都是你无法使用相机测光的时候，其实等于你放弃了相机测光。所以请记住，往往在你无法使用相机测光的时候，才用M挡。</p>
<h2 id="06-光线"><a href="#06-光线" class="headerlink" title="06 光线"></a>06 光线</h2><h3 id="第1节-光线的特性"><a href="#第1节-光线的特性" class="headerlink" title="第1节 光线的特性"></a>第1节 光线的特性</h3><p><strong>顺光</strong></p>
<p>其实顺光不应过多地运用在人像摄影中。因为正面直射的光会消除面部的一切影子，使得面部趋于平面化，所以又叫平光。</p>
<p><strong>侧光</strong></p>
<p>侧光一般用在人物摄影的造型上。相比顺光会将人物拍成“大白脸”，侧光能够让人物的面部呈现立体效果。</p>
<p><strong>逆光</strong></p>
<p>逆光是很多摄影师进行创作的用光。使用逆光拍摄的时候，往往会有雾蒙蒙的感觉，并形成暖色调。</p>
<p><strong>色温</strong></p>
<p>蓝色是冷色，但是色温高；红色是暖色，但是色温低。</p>
<p>日光的色温大概是5500K。白纸放到日光下就是白色的。</p>
<p><strong>白平衡</strong></p>
<p>白平衡是相机机内处理的结果。说白了就是相机自己的后期。所以如果你拍摄RAW格式照片的话，可以在计算机中重新定义白平衡，重新调节。理论上是没有画质损失的（尽管实际可能有，但是也非常小，可忽略）。</p>
<blockquote>
<p>所以AWB+RAW拍摄，是一个既方便，又保险的组合。</p>
</blockquote>
<h3 id="第2节-布光方法"><a href="#第2节-布光方法" class="headerlink" title="第2节 布光方法"></a>第2节 布光方法</h3><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050444659.png" alt="image-20220205044427503" style="zoom:50%;" />

<p><strong>伦勃朗布光法</strong>有几个特点：</p>
<p>1．四分之三面部对着相机。让人物面向相机，缓慢变换角度，直到看不到一侧的耳朵为止。</p>
<p>2．架设主灯，强度要能使人面部正确曝光，方向为与人物面部方向同一侧45°左右。注意，要在人物面部形成三角形光区（以鼻子阴影、面颊阴影、下眼线为边长，围成的三角形亮区）。</p>
<p>3．架设辅灯。将面部阴影处柔化，并表现出细节。一般会使用4:1或者3:1的光比。</p>
<p>4．架设背景灯，打亮背景。如果有可能从人物斜后方放置一束比较集中的光，打在人物轮廓上，形成轮廓光。如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050446673.png" alt="image-20220205044609555" style="zoom:50%;" />



<p>伦勃朗布光法是适用于男性的。那么再提供一个适用于女性摄影的布光法——<strong>蝶形布光法</strong>。</p>
<p><strong>蝶形布光法</strong>的名字来源于布光法中的一个特点。类似于伦勃朗布光法中要找三角形光区，蝶形布光法就是要找这个蝶形。使用蝶形布光法的时候，主灯放置在人物正前方，但是处于比较高的位置。这与顶光不同。蝶形布光法的主灯是从上斜射下来的。这样在人物的鼻子下方就会形成一个阴影。随着主灯高度变化，阴影会在鼻子下面形成一个蝴蝶的形状。这时主灯的位置就可以确定了。</p>
<h2 id="07-摄影中的虚实"><a href="#07-摄影中的虚实" class="headerlink" title="07 摄影中的虚实"></a>07 摄影中的虚实</h2><p><strong>前帘同步闪光</strong>就是：</p>
<p>前帘开启之后（也是曝光的开始），就闪光，闪完了之后等曝光时间一到后帘关闭（曝光结束）。这样就是一辆车移动，你拍摄车。开启快门就闪光了，车被闪光灯定在了画面中，然后长曝光继续曝，车往前走拉车线。这样就变成了车在后面，车线在前面的奇葩照片。</p>
<img src="C:/Users/Yoon/AppData/Roaming/Typora/typora-user-images/image-20220205045502246.png" alt="image-20220205045502246" style="zoom:25%;" />



<p><strong>后帘同步闪光</strong>就是：</p>
<p>前帘开启之后（也是曝光的开始），先踏踏实实曝着光。然后闪光灯闪了一下，定格画面，随即后帘关闭（曝光结束）。这样一辆车移动，你拍摄车。开启快门，先拉车线，然后马上快门关闭了，闪光灯突然把车定格住。就变成了车在前面，车线在后面的好画面了。</p>
<img src="C:/Users/Yoon/AppData/Roaming/Typora/typora-user-images/image-20220205045429391.png" alt="image-20220205045429391" style="zoom:25%;" />

<h2 id="08-构图"><a href="#08-构图" class="headerlink" title="08 构图"></a>08 构图</h2><p><strong>居中构图</strong></p>
<p><strong>三分法构图</strong></p>
<p><strong>重复法</strong></p>
<p><strong>引导线</strong></p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050457311.png" alt="image-20220205045729070" style="zoom:25%;" />

<p><strong>三角构图</strong></p>
]]></content>
      <categories>
        <category>兴趣</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告 - 在线广告概览</title>
    <url>/2022/03/06/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%20(2)/</url>
    <content><![CDATA[<h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1.模型"></a>1.模型</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203061001702.png" alt="image-20220306100052375"></p>
<span id="more"></span>

<h3 id="11-3-1-在线分配问题"><a href="#11-3-1-在线分配问题" class="headerlink" title="11.3.1 在线分配问题"></a>11.3.1 在线分配问题</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203061117646.png" alt="image-20220306111720187"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>智慧营销</category>
      </categories>
      <tags>
        <tag>智慧营销</tag>
      </tags>
  </entry>
  <entry>
    <title>并发/幂等/数据一致性问题</title>
    <url>/2022/02/27/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1、幂等性"><a href="#1、幂等性" class="headerlink" title="1、幂等性"></a>1、幂等性</h1><p>幂等性是数学上的概念：F(F(x))=F(x)，用在接口上就是：多次重复请求，产生效果一致。</p>
<p>比较典型的场景：支付接口，重复支付会导致多次扣钱；订单接口，同一个订单可能会多次创建。如果没有接口幂等性，则会产生数据一致性问题。</p>
<p>在数据库中，常见操作包括：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>： 天然幂等，重复操作产生效果一致;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span>： 删除也是幂等,删除同一个多次效果一样;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span>： 非幂等操作,每次新增一条;</span><br><span class="line"></span><br><span class="line">UPDATE： a.直接更新某个值的,幂等;</span><br><span class="line">      ： b.更新累加操作的,非幂等;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="2、RestFul规范"><a href="#2、RestFul规范" class="headerlink" title="2、RestFul规范"></a>2、RestFul规范</h1><h3 id="Create-类型的幂等"><a href="#Create-类型的幂等" class="headerlink" title="Create 类型的幂等"></a>Create 类型的幂等</h3><p>创建类型的 API，为了实现幂等性，常见的做法是使用一个 client-side generated deduplication token（客户端生成的唯一ID），在反复重试时使用同一个Token，便于服务端识别重复，如果发现重复，应按创建成功返回。</p>
<h3 id="Update-类型的幂等"><a href="#Update-类型的幂等" class="headerlink" title="Update 类型的幂等"></a>Update 类型的幂等</h3><p>更新类型的 API，通常有唯一ID对需要更新的资源进行标示，以此可以保证幂等。</p>
<p>对于“Delta”语义的操作，有以下几类方式确保幂等性：</p>
<ol>
<li>IncrementBy：基于某个数值增加</li>
<li>SetNewTotal：设置新的总量</li>
<li>使用 Deduplication Token 保证幂等</li>
</ol>
<p>这几种方式各有优缺点，需要根据场景选择合适的方式。</p>
<h3 id="Delete-类型的幂等"><a href="#Delete-类型的幂等" class="headerlink" title="Delete 类型的幂等"></a>Delete 类型的幂等</h3><p>Delete的幂等性问题，往往在于一个对象被删除后，再次试图删除可能会由于数据无法被发现导致出错。这个行为一般来说也没什么问题，虽然严格意义上不幂等，但是也无副作用。</p>
<h3 id="长耗时请求异步化"><a href="#长耗时请求异步化" class="headerlink" title="*** 长耗时请求异步化 ***"></a>*** 长耗时请求异步化 ***</h3><p>如果某个 API 方法需要很长时间才能完成，可以通过：</p>
<ol>
<li>在服务端异步启动任务，并返回 GUID 标示 “长时间运行的操作”资源</li>
<li>客户端通过定时轮询 <em>/polling/{guid}，</em> 获取任务进行的状态。</li>
<li>当任务完成/失败时，客户端可以获取到处理的结果/失败原因。</li>
</ol>
<h1 id="3、Redis分布式锁"><a href="#3、Redis分布式锁" class="headerlink" title="3、Redis分布式锁"></a>3、Redis分布式锁</h1><h2 id="设计方案："><a href="#设计方案：" class="headerlink" title="设计方案："></a><strong>设计方案：</strong></h2><ul>
<li><p>拦截注解 @RedisLock，获取必要的参数</p>
</li>
<li><p>加锁操作</p>
</li>
<li><p>续时操作</p>
</li>
<li><p>结束业务，释放锁</p>
</li>
</ul>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h4 id="（1）业务属性枚举设定"><a href="#（1）业务属性枚举设定" class="headerlink" title="（1）业务属性枚举设定"></a>（1）业务属性枚举设定</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RedisLockTypeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义 key 前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ONE(<span class="string">&quot;Business1&quot;</span>, <span class="string">&quot;Test1&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    TWO(<span class="string">&quot;Business2&quot;</span>, <span class="string">&quot;Test2&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    RedisLockTypeEnum(String code, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUniqueKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;%s:%s&quot;</span>, <span class="keyword">this</span>.getCode(), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（2）任务队列保存参数"><a href="#（2）任务队列保存参数" class="headerlink" title="（2）任务队列保存参数"></a><strong>（2）任务队列保存参数</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisLockDefinitionHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务唯一 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String businessKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁时间 (秒 s)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long lockTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次更新时间（ms）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long lastModifyTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Thread currentTread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总共尝试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tryCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前尝试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentCount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时间周期（毫秒）,公式 = 加锁时间（转成毫秒） / 3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long modifyPeriod;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisLockDefinitionHolder</span><span class="params">(String businessKey, Long lockTime, Long lastModifyTime, Thread currentTread, <span class="keyword">int</span> tryCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.businessKey = businessKey;</span><br><span class="line">        <span class="keyword">this</span>.lockTime = lockTime;</span><br><span class="line">        <span class="keyword">this</span>.lastModifyTime = lastModifyTime;</span><br><span class="line">        <span class="keyword">this</span>.currentTread = currentTread;</span><br><span class="line">        <span class="keyword">this</span>.tryCount = tryCount;</span><br><span class="line">        <span class="keyword">this</span>.modifyPeriod = lockTime * <span class="number">1000</span> / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="（3）设定被拦截的注解名字"><a href="#（3）设定被拦截的注解名字" class="headerlink" title="（3）设定被拦截的注解名字"></a><strong>（3）设定被拦截的注解名字</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisLockAnnotation &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 特定参数识别，默认取第 0 个下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lockFiled</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">tryCount</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义加锁类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RedisLockTypeEnum <span class="title">typeEnum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放时间，秒 s 单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">lockTime</span><span class="params">()</span> <span class="keyword">default</span> 30</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（4）-核心切面拦截的操作"><a href="#（4）-核心切面拦截的操作" class="headerlink" title="（4） 核心切面拦截的操作"></a><strong>（4）</strong> <strong>核心切面拦截的操作</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@annotation</span> 中的路径表示拦截特定注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;@annotation(cn.sevenyuan.demo.aop.lock.RedisLockAnnotation)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redisLockPC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(value = &quot;redisLockPC()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    Method method = resolveMethod(pjp);</span><br><span class="line">    RedisLockAnnotation annotation = method.getAnnotation(RedisLockAnnotation.class);</span><br><span class="line">    RedisLockTypeEnum typeEnum = annotation.typeEnum();</span><br><span class="line">    Object[] params = pjp.getArgs();</span><br><span class="line">    String ukString = params[annotation.lockFiled()].toString();</span><br><span class="line">    <span class="comment">// 省略很多参数校验和判空</span></span><br><span class="line">    String businessKey = typeEnum.getUniqueKey(ukString);</span><br><span class="line">    String uniqueValue = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = redisTemplate.opsForValue().setIfAbsent(businessKey, uniqueValue);</span><br><span class="line">        <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;You can&#x27;t do it，because another has get the lock =-=&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        redisTemplate.expire(businessKey, annotation.lockTime(), TimeUnit.SECONDS);</span><br><span class="line">        Thread currentThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 将本次 Task 信息加入「延时」队列中</span></span><br><span class="line">        holderList.add(<span class="keyword">new</span> RedisLockDefinitionHolder(businessKey, annotation.lockTime(), System.currentTimeMillis(),</span><br><span class="line">                currentThread, annotation.tryCount()));</span><br><span class="line">        <span class="comment">// 执行业务操作</span></span><br><span class="line">        result = pjp.proceed();</span><br><span class="line">        <span class="comment">// 线程被中断，抛出异常，中断此次请求</span></span><br><span class="line">        <span class="keyword">if</span> (currentThread.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(<span class="string">&quot;You had been interrupted =-=&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e ) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Interrupt exception, rollback transaction&quot;</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Interrupt exception, please send request again&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;has some error, please check again&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 请求结束后，强制删掉 key，释放锁</span></span><br><span class="line">        redisTemplate.delete(businessKey);</span><br><span class="line">        log.info(<span class="string">&quot;release the lock, businessKey is [&quot;</span> + businessKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="（5）-延时操作"><a href="#（5）-延时操作" class="headerlink" title="（5） 延时操作"></a><strong>（5） 延时操作</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扫描的任务队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentLinkedQueue&lt;RedisLockDefinitionHolder&gt; holderList = <span class="keyword">new</span> ConcurrentLinkedQueue();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池，维护keyAliveTime</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService SCHEDULER = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">        <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;redisLock-schedule-pool&quot;</span>).daemon(<span class="keyword">true</span>).build());</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 两秒执行一次「续时」操作</span></span><br><span class="line">    SCHEDULER.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 这里记得加 try-catch，否者报错后定时任务将不会再执行=-=</span></span><br><span class="line">        Iterator&lt;RedisLockDefinitionHolder&gt; iterator = holderList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            RedisLockDefinitionHolder holder = iterator.next();</span><br><span class="line">            <span class="comment">// 判空</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断 key 是否还有效，无效的话进行移除</span></span><br><span class="line">            <span class="keyword">if</span> (redisTemplate.opsForValue().get(holder.getBusinessKey()) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超时重试次数，超过时给线程设定中断</span></span><br><span class="line">            <span class="keyword">if</span> (holder.getCurrentCount() &gt; holder.getTryCount()) &#123;</span><br><span class="line">                holder.getCurrentTread().interrupt();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否进入最后三分之一时间</span></span><br><span class="line">            <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">boolean</span> shouldExtend = (holder.getLastModifyTime() + holder.getModifyPeriod()) &lt;= curTime;</span><br><span class="line">            <span class="keyword">if</span> (shouldExtend) &#123;</span><br><span class="line">                holder.setLastModifyTime(curTime);</span><br><span class="line">                redisTemplate.expire(holder.getBusinessKey(), holder.getLockTime(), TimeUnit.SECONDS);</span><br><span class="line">                log.info(<span class="string">&quot;businessKey : [&quot;</span> + holder.getBusinessKey() + <span class="string">&quot;], try count : &quot;</span> + holder.getCurrentCount());</span><br><span class="line">                holder.setCurrentCount(holder.getCurrentCount() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4、数据库乐观锁与悲观锁"><a href="#4、数据库乐观锁与悲观锁" class="headerlink" title="4、数据库乐观锁与悲观锁"></a>4、数据库乐观锁与悲观锁</h1><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code> <code>redis分布式锁</code>等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h3 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h3><blockquote>
<p><strong>乐观锁一般会使用版本号机制或CAS算法实现。</strong></p>
</blockquote>
<h4 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子：</strong> 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p>
<h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<h3 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h3><blockquote>
<p>ABA 问题是乐观锁一个常见的问题</p>
</blockquote>
<h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h4><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h4 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h4><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h4 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h4><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h3 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h3><blockquote>
<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>
</blockquote>
<ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ol>
<p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>
<h1 id="5-总结："><a href="#5-总结：" class="headerlink" title="5.总结："></a>5.总结：</h1><p>主要讨论了并发场景读写一致性问题，对于长耗时请求问题，还是不懂怎么解决。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告 - 计算广告基础</title>
    <url>/2022/03/06/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A/</url>
    <content><![CDATA[<h3 id="1-广告有效性模型"><a href="#1-广告有效性模型" class="headerlink" title="1.广告有效性模型"></a>1.广告有效性模型</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271103448.png" alt="image-20220227110314006"></p>
<span id="more"></span>

<p><strong>曝光</strong>：主要取决于广告位</p>
<p><strong>关注</strong>：不要干扰打断用户行为、符合用户兴趣和需求</p>
<p><strong>理解</strong>：在用户能理解的具体兴趣范围内</p>
<p><strong>接受</strong>：表达信息恰当</p>
<p><strong>保持</strong>：创意设计</p>
<p><strong>决策</strong>：具体的广告策略或技术</p>
<h3 id="2-计算广告核心挑战"><a href="#2-计算广告核心挑战" class="headerlink" title="2.计算广告核心挑战"></a>2.计算广告核心挑战</h3><ul>
<li><p>计算广告的核心问题，是为一系列用户与环境的组合找到最合适的广告投放策略以优化整体广告活动的利润。</p>
</li>
<li><p>优化问题描述：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271111882.png" alt="image-20220227111138694"></p>
<p>表达式中的 a、u、c 三个变量，分别代表广告、用户与环境。</p>
</li>
</ul>
<h3 id="3-广告收入分解"><a href="#3-广告收入分解" class="headerlink" title="3.广告收入分解"></a>3.广告收入分解</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271119335.png" alt="image-20220227111957205"></p>
<p>广告点击与广告展现的比率称为 <strong>点击率（Click Through Rate，CTR）</strong>；</p>
<p>点击行为成功以后，将会打开广告主的 <strong>落地页（landing page）</strong>；</p>
<p>落地页成功打开次数与点击次数的比例称为 <strong>到达率</strong>；</p>
<p>如果用户从落地页开始，进一步完成下单等操作，则称为 <strong>转化</strong>；</p>
<p>转化次数与到达次数的比例称为 <strong>转化率（Conversion Rate，CVR）</strong>；</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271121325.png" alt="image-20220227112106244"></p>
<p>用 <strong>µ</strong> 表示点击率，用 <strong>ν</strong> 表示点击价值（clickvalue），即单次点击为广告产品带来的收益。而这两部分的乘积定量地表示了某次或若干次展示的期望 CPM 值，就是前面提到的 eCPM[4]。</p>
<p>在对多个检索候选进行排序时，是根据 <strong>eCPM</strong> 还是<strong>CTR排序</strong>也是区别广告产品和用户产品的重要策略特征。</p>
<h3 id="4-结算方式"><a href="#4-结算方式" class="headerlink" title="4.结算方式"></a>4.结算方式</h3><p>表 2-1 展示了以上几种结算方式概要的对比。综合来看可以认为，对于效果广告，CPC计费方式最有利于发挥供给方和需求方的长处，因而在市场上被广泛接受；对于品牌广告，由于效果和目的有时不便于直接衡量，可以考虑按照 CPM 的方式计费；而CPS 的计费方式只在一些特定的环境下才比较合理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202271125174.png" alt="image-20220227112520031"></p>
<p>在 CPC 或 CPS 结算的广告交易中，由于计费的指标，即点击或转化在广告主的网站上产生，所以并不需要特别的监测服务。因此，可以认为广告监测主要服务的对象是品牌广告主。随着 CPM 广告定向方式越来越复杂，广告监测也从简单的展示和点击记数到频次、人口属性等信息的验证和计量。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>智慧营销</category>
      </categories>
      <tags>
        <tag>智慧营销</tag>
      </tags>
  </entry>
  <entry>
    <title>计算广告 - 定价机制</title>
    <url>/2022/03/20/%E8%AE%A1%E7%AE%97%E5%B9%BF%E5%91%8A%20(3)/</url>
    <content><![CDATA[<p>在进行广告位拍卖时，广告主会不停地试探广告费用下限，从而影响媒体收益。要想理解市场如何达到稳定状态，需要理解三个概念：纳什均衡、广义第二高价、VCG（Vickrey-Clarke-Groves）定价策略。</p>
<h4 id="1-纳什均衡"><a href="#1-纳什均衡" class="headerlink" title="1.纳什均衡"></a>1.纳什均衡</h4><p>即每个广告主都通过出价得到了最符合自己利益的位置。对某一次位置竞价来说，其对称纳什均衡（symmetric Nashequilibrium）状态可以表示为下式：</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203202316893.png" alt="image-20220320231605798" style="zoom: 67%;" />

<p>注意这里的下标意义有所调整，这里的 νs 指的是排在 s 位置上的广告的点击价值，并非 s 位置带来的点击价值，而 qs 指的是市场向排在 s 位置上的广告收取的费用，即定价，也就是广告主的单次投入。这一均衡状态的意义很容易理解：对于最终位置排名竞价结果中的每一条广告，其收益都比排在其他位置上要高。显然，在这样的状态下，每个广告主都达到了自己最优的状态，整个系统也就随之稳定下来。</p>
<span id="more"></span>

<h4 id="2-广义第二高价"><a href="#2-广义第二高价" class="headerlink" title="2.广义第二高价"></a>2.广义第二高价</h4><p><strong>第二高价</strong>：指的是在只有一个位置的拍卖中，向赢得该位置的广告主收取其下一位广告主的出价。</p>
<p><strong>广义第二高价</strong>：在搜索广告这种有多个位置的拍卖过程中，对赢得每一个位置的广告主，都按照他下一位的广告位置出价来收取费用。 </p>
<p>实际上，第二高价是单位置拍卖时的最优定价策略，然而广义第二高价却不是多位置拍卖时的最优定价策略（最优策略是下面要介绍的 VCG 定价）。虽然并非理论上最优，广义第二高价却有着实现简单、容易向广告主解释等诸多操作中的优点，因此在实际的竞价广告系统中是<strong>最主流的定价策略</strong>。</p>
<h4 id="3-VCG-定价"><a href="#3-VCG-定价" class="headerlink" title="3.VCG 定价"></a>3.VCG 定价</h4><p>是 Vickrey、Clarke 和 Groves 在研究竞价系统均衡状态时得到的一种理论上较为优越的定价策略。其基本思想是：对于赢得了某个位置的广告主，其所付出的成本应该等于他占据这个位置给其他市场参与者带来的价值损害。在这一原则下，VCG的定价策略可以表示为公式 5.3。</p>
<img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203202325229.png" alt="image-20220320232531146" style="zoom:67%;" />

<p>理论分析表明，VCG 定价策略的优越性体现在如下几个方面：</p>
<p>首先，在这种定价策略的稳定状态下，整个市场是truth-telling的。所谓 truth-telling，可以理解为每个广告主都找到了自己的最优状态。</p>
<p>其次，相对于其他的定价策略，这种定价向广告主收取的费用是最少的。在单广告位拍卖的情形下，VCG定价策略就退化为第二高价策略。</p>
<p>虽然有以上诸多的优点，VCG 定价在竞价广告中却并不是一种主流的方式。这主要是由于：</p>
<ul>
<li><p>逻辑过于复杂，比较难以向广告主解释清楚；</p>
</li>
<li><p>另外在广告主和媒体存在博弈关系的情形下，媒体是否正确地计算了“给其他市场参与者带来的价值损害”也很难验证。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>智慧营销</category>
      </categories>
      <tags>
        <tag>智慧营销</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件</title>
    <url>/2022/01/18/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h3 id="主要使用到的技术包括："><a href="#主要使用到的技术包括：" class="headerlink" title="主要使用到的技术包括："></a>主要使用到的技术包括：</h3><h4 id="springboot-spring-cloud-mybatis-redis-ehcache-rabbit-mq-AWS-S3-mysql"><a href="#springboot-spring-cloud-mybatis-redis-ehcache-rabbit-mq-AWS-S3-mysql" class="headerlink" title="springboot + spring cloud + mybatis + redis + ehcache + rabbit mq + AWS S3 + mysql"></a>springboot + spring cloud + mybatis + redis + ehcache + rabbit mq + AWS S3 + mysql</h4><h3 id="ehcache"><a href="#ehcache" class="headerlink" title="ehcache"></a><strong>ehcache</strong></h3><p>EhCache直接在JVM中进行缓存，速度快，效率高。与Redis相比，操作简单、易用、高效，虽然EhCache也提供有缓存共享的方案，但对分布式集群的支持不太好，缓存共享实现麻烦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value &#x3D; &quot;hacCache&quot;, key &#x3D; &quot;targetClass+methodName+#p0&quot;)</span><br><span class="line">@CachePut 用于新增</span><br><span class="line">@CacheEvict 用于删除</span><br><span class="line">@Caching 用于组合条件</span><br></pre></td></tr></table></figure>



<h3 id="redis-缓存、分布式锁、事务、持久化存储"><a href="#redis-缓存、分布式锁、事务、持久化存储" class="headerlink" title="redis:缓存、分布式锁、事务、持久化存储"></a>redis:缓存、分布式锁、事务、持久化存储</h3><p>redis单线程为什么这么快 ？</p>
<p>redis 常见数据结构以及使用场景分析 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. String：key-value类型 常规key-value缓存应用； 常规计数：微博数，粉丝数等。 </span><br><span class="line"></span><br><span class="line">2. Hash 是一个 string 类型的 field 和 value 的映射表。</span><br><span class="line">   hash 特别适合用于存储对象，后续操作的时候，可以直接仅仅修改这个对象中的某个字段的值。</span><br><span class="line">   比如存储用户信息，商品信息等等</span><br><span class="line"></span><br><span class="line">3. List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作</span><br><span class="line">   微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。</span><br><span class="line"></span><br><span class="line">4. Set 是可以自动排重的。</span><br><span class="line">   Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程</span><br><span class="line"></span><br><span class="line">5. Sorted Set 增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 </span><br><span class="line">   举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜</span><br></pre></td></tr></table></figure>

<p>删除机制</p>
<p>哨兵机制</p>
<p>缓存穿透 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：</span><br><span class="line">一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量</span><br><span class="line">请求而崩掉。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line">最常见的是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</span><br><span class="line">另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</span><br></pre></td></tr></table></figure>

<p>缓存雪崩 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。 解决办法：</span><br><span class="line"></span><br><span class="line">事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。 </span><br><span class="line"></span><br><span class="line">事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉 </span><br><span class="line"></span><br><span class="line">事后：利用 redis 持久化机制保存的数据尽快恢复缓存</span><br></pre></td></tr></table></figure>



<p>extends WebSecurityConfigurerAdapter</p>
<p>implements Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Group group;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    <span class="keyword">private</span> Long creatorId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(baseUrls, <span class="number">0</span>, urls, excludeUrls.size(), baseUrls.length);</span><br><span class="line">        http.csrf().disable()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(urls).permitAll()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/api/admin/users&quot;</span>, <span class="string">&quot;/api/admin/groups&quot;</span>).hasAnyRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 登录和权限校验失败处理</span></span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">            .authenticationEntryPoint((request, response, authException)</span><br><span class="line">                -&gt; &#123;</span><br><span class="line">                Map&lt;String, String&gt; message = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">                message.put(<span class="string">&quot;message&quot;</span>, I18nContext.getMessage(<span class="string">&quot;AUTH_ERROR_403_17&quot;</span>));</span><br><span class="line">                message.put(<span class="string">&quot;url&quot;</span>, ContextConfig.getConf(<span class="string">&quot;WEB_OAUTH_LOGIN_URL&quot;</span>));</span><br><span class="line">                response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">                MessageUtils.respMsg(response, message);</span><br><span class="line">            &#125;)</span><br><span class="line">            .accessDeniedHandler((request, response, accessDeniedException)</span><br><span class="line">                -&gt; MessageUtils.respStringMsg(HttpStatus.FORBIDDEN));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add filter</span></span><br><span class="line">        http.addFilterBefore(<span class="keyword">new</span> OauthLoginFilter(sysUserService),</span><br><span class="line">            UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="rabbit-mq"><a href="#rabbit-mq" class="headerlink" title="rabbit-mq"></a>rabbit-mq</h3><p>{      service:</p>
<p>​        resource:</p>
<p>​        taskId:</p>
<p>​        status:    }</p>
<p>模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Direct exchange:routingkey完全匹配</span><br><span class="line">Fanout exchange：订阅模式，exchange绑定的所有队列</span><br><span class="line">Topic exchange：routingkey通配</span><br><span class="line">Headers exchange：不通过routingkey,通过请求头信息</span><br></pre></td></tr></table></figure>



<p>死信队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DLX，全称为Dead-Letter-Exchange , 可以称之为死信交换机。当消息在一个队列中变成死信(dead message)之后，它能被重新发送到另一个交换机中，这个交换机就是DLX ，绑定DLX的队列就称之为死信队列。</span><br><span class="line"></span><br><span class="line">消息变成死信，可能是由于以下的原因：</span><br><span class="line"></span><br><span class="line">- 消息被拒绝</span><br><span class="line">- 消息过期</span><br><span class="line">- 队列达到最大长度</span><br><span class="line"></span><br><span class="line">DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，Rabbitmq就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogOperation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模块信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">operation</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哪些字段需要被操作日志锁记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] fields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哪些字段需要联合判断，如时间字段:begin-end</span></span><br><span class="line"><span class="comment">     * 当其中一个字段发生变化即认为两者都发生变化。</span></span><br><span class="line"><span class="comment">     * 说明:unionFields中字段不要在fields中存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String [] unionFields() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作日志中的操作（） 中的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">operationField</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作者,SpEL表达式，默认从权限工具类获取。</span></span><br><span class="line"><span class="comment">     * hoa-log 可以不用依赖hoa-security模块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">operator</span><span class="params">()</span> <span class="keyword">default</span> &quot;@userServiceImpl.<span class="title">getCurrentUser</span><span class="params">()</span>.<span class="title">getId</span><span class="params">()</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作前的值,使用 SPEL 表达式，参考如下：</span></span><br><span class="line"><span class="comment">     * #this.getDao().findOne(#p0.id)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">originExpression</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作后的值，使用 SPEL 表达式，参考如下：</span></span><br><span class="line"><span class="comment">     * #p0</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">currentExpression</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 SPEL 表达式判断在什么情况下记录本次的操作日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;<span class="keyword">true</span>&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;$&#123;app.monitor.task.day&#125;&quot;)</span></span><br><span class="line"><span class="meta">@SchedulerLock(name = &quot;HCM_SUBSCRIPTION_DAY&quot;, lockAtLeastFor = 30000, lockAtMostFor = 60000)</span></span><br></pre></td></tr></table></figure>



<h3 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h3><h3 id="openfeign"><a href="#openfeign" class="headerlink" title="openfeign"></a>openfeign</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@FeignClient</span>:</span></span><br><span class="line"><span class="comment"> *  name/value属性: 这两个的作用是一样的,指定的是调用服务的微服务名称</span></span><br><span class="line"><span class="comment"> *  url : 指定调用服务的全路径,经常用于本地测试</span></span><br><span class="line"><span class="comment"> *  如果同时指定name和url属性: 则以url属性为准,name属性指定的值便当做客户端的名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/6/3 1:56 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;$&#123;openfeign.hac.accountClient&#125;&quot;, url = &quot;$&#123;openfeign.hac.accountDomain&#125;&quot;,</span></span><br><span class="line"><span class="meta">        fallbackFactory = FeignHacBackService.class, configuration = FeignConfiguration.class)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignHacService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;$&#123;openfeign.hac.userApi&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">HacMessage&lt;HacUser&gt; <span class="title">syncUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">             </span><br></pre></td></tr></table></figure>

<h3 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud"></a>spring cloud</h3>]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基础语法</title>
    <url>/2022/01/19/java%E5%85%AB%E8%82%A1%E6%96%87-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-面向对象包括哪些特性，如何理解？"><a href="#1-面向对象包括哪些特性，如何理解？" class="headerlink" title="1.面向对象包括哪些特性，如何理解？"></a>1.面向对象包括哪些特性，如何理解？</h3><ul>
<li><p>封装。通过private关键字，将对象的属性和方法封装起来。隐藏一切可隐藏的东西，只对外界提供最简单的编程接口，同时保护了数据。</p>
</li>
<li><p>继承。父类引用指向子类对象，Animal animal = new Cat( ) 即声明的是父类，实际指向的是子类的一个对象。 继承是为了重用父类代码，子类继承父类就拥有了父类的成员。</p>
</li>
<li><p>多态。同一个行为具有不同的表现形式。实现多态需要做两件事：</p>
<p>第一：方法重写（子类继承父类并重写父类中已有的或抽象的方法）</p>
<p>第二：对象造型（用父类引用指向子类对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<span id="more"></span></li>
</ul>
<h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><p><strong>重载</strong> : 发生在同一个类中。方法名一样，方法参数类型、个数、顺序不一样。返回值类型和访问权限可以不一致。</p>
<p><strong>重写</strong> ：发生在父子类中，子类重写父类方法。方法名一样，方法返回值小于等于父类，方法访问权限大于等于父类。当父类中方法使用private修饰时，子类不能重写父类中的方法。</p>
<h3 id="3-String、StringBuffer、StingBuilder的区别"><a href="#3-String、StringBuffer、StingBuilder的区别" class="headerlink" title="3.String、StringBuffer、StingBuilder的区别"></a>3.String、StringBuffer、StingBuilder的区别</h3><ul>
<li><p><strong>可变性</strong></p>
<p>String类中使用final关键字字符数组保存字符串，所以String是不可变字符串。</p>
<p>StringBuilder和StringBuffer都继承自AbstractStringBuilder，因此两者都是可变字符串</p>
</li>
<li><p><strong>线程安全性</strong></p>
<p>String可以理解为字符串常量，因此是线程安全的。</p>
<p>StringBuffer对方法或者调用的方法加了同步锁，因此也是线程安全的。</p>
<p>StringBuilder并没有对方法加同步锁，所以是非线程安全的。</p>
</li>
<li><p><strong>性能</strong></p>
<p>String每次都会创建一个新的对象，并将指针指向这个新对象。</p>
<p>StringBuffer每次都是对对象本身进行操作，相同情况下，StringBuilder比StringBuffer的性能提升10%-15%，却要承担线程不安全的风险</p>
</li>
<li><p>使用总结：</p>
<p>对字符串进行少量修改：使用String</p>
<p>多线程操作字符串缓冲区下操作大量数据：StringBuffer</p>
<p>单线程操作字符串缓冲区下操作大量数据：StringBuilder</p>
</li>
</ul>
<h3 id="4-自动装箱与自动拆箱"><a href="#4-自动装箱与自动拆箱" class="headerlink" title="4.自动装箱与自动拆箱"></a>4.自动装箱与自动拆箱</h3><p>自动装箱：将基本数据类型用他们对应的包装数据类型包装起来</p>
<p>自动拆箱：将包装数据类型转化为基本数据类型</p>
<blockquote>
<p>在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
</blockquote>
<h3 id="5-关于final关键字的总结"><a href="#5-关于final关键字的总结" class="headerlink" title="5.关于final关键字的总结"></a>5.关于final关键字的总结</h3><p>final关键字主要用在三个地方：类、方法、变量。</p>
<ul>
<li>当final修饰变量时，一旦变量被初始化，就不可以被随意更改。</li>
<li>当final修饰方法时，这个方法不可以被覆盖重写。</li>
<li>当final修饰类时，该类不可以被继承，类中的方法被隐式地申明为final方法。</li>
</ul>
<p>使用final类的好处如下：第一是把方法锁住，防止继承类修改它的含义；第二是提升性能，在早期的Java版本中，final方法会转化为嵌入方法，不过现在的Java版本已经不靠final来提升方法性能了。</p>
<h3 id="6-Object类的常用方法总结"><a href="#6-Object类的常用方法总结" class="headerlink" title="6.Object类的常用方法总结"></a>6.Object类的常用方法总结</h3><p>Object类是一个特殊的类，它是所有类的父类，主要提供了以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- toString() </span><br><span class="line">    </span><br><span class="line">- hashCode()</span><br><span class="line">    </span><br><span class="line">- getClass() <span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line">    </span><br><span class="line">- equals() <span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span><br><span class="line">    </span><br><span class="line">- clone() <span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass()== x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span><br><span class="line">    </span><br><span class="line">- notify() <span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"></span><br><span class="line">- notifyAll() <span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"></span><br><span class="line">- wait() <span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span><br><span class="line"></span><br><span class="line">- finalize() <span class="comment">//实例被垃圾回收器回收的时候触发的操作     </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-Java中的异常处理"><a href="#7-Java中的异常处理" class="headerlink" title="7.Java中的异常处理"></a>7.Java中的异常处理</h3><h4 id="7-1-异常分类"><a href="#7-1-异常分类" class="headerlink" title="7.1 异常分类"></a>7.1 异常分类</h4><p>在Java中所有的异常都有一个共同的父类<strong>Throwable</strong>类，Throwable类有两个重要的子类：**Error **和 <strong>Exception</strong>。</p>
<p>Error是程序无法处理的异常，Exception是程序可以处理的异常。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202203192311254.png" alt="image-20220319231142003"></p>
<h4 id="7-2-异常处理"><a href="#7-2-异常处理" class="headerlink" title="7.2 异常处理"></a>7.2 异常处理</h4><p>处理方式：</p>
<ol>
<li>不处理，直接抛出异常</li>
<li>使用 try catch 捕获处理异常</li>
</ol>
<h4 id="7-3-throw-throws区别"><a href="#7-3-throw-throws区别" class="headerlink" title="7.3 throw throws区别"></a>7.3 throw throws区别</h4><h5 id="位置不同："><a href="#位置不同：" class="headerlink" title="位置不同："></a>位置不同：</h5><p>throws: 使用在函数上，后面跟的是异常类，可以跟多个</p>
<p>throw: 使用用在方法内，后面跟的是异常对象，只能跟一个</p>
<h5 id="功能不同："><a href="#功能不同：" class="headerlink" title="功能不同："></a>功能不同：</h5><p>throws: 申明可能抛出的异常，不一定发生，可以进行预处理</p>
<p>throw: 功能执行到此结束，将具体异常对象抛给调用者</p>
<h3 id="8-接口和抽象类的区别是什么"><a href="#8-接口和抽象类的区别是什么" class="headerlink" title="8.接口和抽象类的区别是什么"></a>8.接口和抽象类的区别是什么</h3><ol>
<li><p>接口类的变量必须是final类型，抽象类不一定</p>
</li>
<li><p>接口类的方法默认加了public abstract JDK1.8之后接口类可以具有默认的实现方法</p>
<p>抽象类中可以有非抽象的方法</p>
</li>
<li><p>子类可以继承一个或多个接口，却只能继承一个抽象方法</p>
</li>
<li><p>继承了接口的子类必须实现接口的所有抽象方法，继承了抽象类的子类可以不完全实现，但是不完全实现的子类也会自动转换为抽象类</p>
</li>
</ol>
<h3 id="9-反射"><a href="#9-反射" class="headerlink" title="9.反射"></a>9.反射</h3><p>在 Java 中的反射机制是指<strong>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法</strong>；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p>
<h4 id="9-1-编译时类型和运行时类型"><a href="#9-1-编译时类型和运行时类型" class="headerlink" title="9.1 编译时类型和运行时类型"></a>9.1 编译时类型和运行时类型</h4><blockquote>
<p> Person p = new Student （）；</p>
</blockquote>
<p>编译时类型为Person，运行时类型为Student，当程序需要获取运行时的对象属性和方法时，需要用到反射机制</p>
<h4 id="9-2-反射API"><a href="#9-2-反射API" class="headerlink" title="9.2 反射API"></a>9.2 反射API</h4><p>class 类：反射的核心类，用来获取对象的属性和方法等</p>
<p>field 类：反射的基本类，用来表示对象的变量，可以用来获取和修改属性值</p>
<p>method 类：反射的基本类，用来获取对象的方法</p>
<p> constructor 类：java . lang . reflect 类中方法，表示类的构造方法</p>
<h4 id="9-3-获取对象的三种方法"><a href="#9-3-获取对象的三种方法" class="headerlink" title="9.3 获取对象的三种方法"></a>9.3 获取对象的三种方法</h4><p><strong>调用某个对象的 getClass() 方法</strong></p>
<blockquote>
<p>Person p = new Person();</p>
<p>Class clazz = p.getClass();</p>
</blockquote>
<p><strong>调用某个类的 class 属性</strong></p>
<blockquote>
<p>Class clazz = Person.Class;</p>
</blockquote>
<p><strong>使用forName()方法</strong></p>
<blockquote>
<p>Class clazz = Class.forName(“类的全限定名称”);  //最常用的方法</p>
</blockquote>
<h4 id="9-4-操作反射相关的API"><a href="#9-4-操作反射相关的API" class="headerlink" title="9.4 操作反射相关的API"></a>9.4 操作反射相关的API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 Person 类的 Class 对象</span></span><br><span class="line"> Class clazz=Class.forName(<span class="string">&quot;reflection.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Person 类的所有方法信息</span></span><br><span class="line"> Method[] method=clazz.getDeclaredMethods();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取 Person 类的所有成员属性信息</span></span><br><span class="line"> Field[] field=clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Person 类的所有构造方法信息</span></span><br><span class="line"> Constructor[] constructor=clazz.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>



<h3 id="10-注解"><a href="#10-注解" class="headerlink" title="10.注解"></a>10.注解</h3><p><strong>Annatation</strong>(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息。</p>
<p><strong>@Target 修饰的对象范围</strong> </p>
<p>@Target说明了Annotation所修饰的对象范围： Annotation可被用于 packages、types（类、 接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数 和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰 其修饰的目标 </p>
<p><strong>@Retention 定义 被保留的时间长短</strong> </p>
<p>Retention 定义了该 Annotation 被保留的时间长短：表示需要在什么级别保存注解信息，用于描 述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由：  SOURCE:在源文件中有效（即源文件保留）  CLASS:在 class 文件中有效（即 class 保留）  RUNTIME:在运行时有效（即运行时保留） </p>
<p><strong>@Documented 描述-javadoc</strong></p>
<p><strong>@ Documented 用于描述其它类型的 annotation</strong> 应该被作为被标注的程序成员的公共 API，</p>
<h3 id="11-浅拷贝与深拷贝"><a href="#11-浅拷贝与深拷贝" class="headerlink" title="11.浅拷贝与深拷贝"></a>11.浅拷贝与深拷贝</h3><p><strong>浅拷贝</strong>：对基本数据类型进行<strong>值传递</strong>，对引用数据类型进行<strong>引用传递</strong></p>
<p><strong>深拷贝</strong>：对基本数据类型进行<strong>值传递</strong>，对引用数据类型，创建一个新的对象，并复制其内容</p>
<p>对 clone() 方法，只能对当前对象进行浅拷贝，引用类型依然是在传递引用。</p>
<p>那么，如何进行一个深拷贝呢？</p>
<p>比较常用的方案有两种：</p>
<ol>
<li>序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li>
<li>继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。</li>
</ol>
<h2 id="二、集合框架"><a href="#二、集合框架" class="headerlink" title="二、集合框架"></a>二、集合框架</h2><h3 id="1-List集合"><a href="#1-List集合" class="headerlink" title="1.List集合"></a><strong>1.List集合</strong></h3><p> <strong>ArrayList ：</strong> 数据结构底层是 Object 数组。扩容时，需要将已经有数组的数据复制到新的存储空间中。适合随机查找和遍历，不适合插入和删除。</p>
<p><strong>Vector ：</strong> 数据结构底层是 Object 数组。支持线程的同步。<font color = #bbbb>即某一时刻只有一 个线程能够写 Vector，避免多线程同时写而引起的不一致性，</font>但实现同步需要很高的花费，因此， 访问它比访问 ArrayList 慢。</p>
<p><strong>LinkedList ：</strong>数据结构底层是双向链表。很适合数据的动态插入和删除，随机访问和遍历速度比较 慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆、栈、队列和双向队列使用。</p>
<h3 id="2-Set集合"><a href="#2-Set集合" class="headerlink" title="2.Set集合"></a>2.Set集合</h3><p><strong>HashSet ：</strong> <font color=#bbbb>存储元素的顺序并不是按照存入时的顺序（和 List 显然不 同）</font> 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法。</p>
<p><strong>TreeSet：</strong> </p>
<ol>
<li><p>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增 加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </p>
</li>
<li><p>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，<font color=#bbbb>自定义的类必须实现 Comparable 接口，并且重写相应的 compareTo()函数，</font>才可以正常使 用。 </p>
</li>
<li><p> 在覆写 compareTo()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </p>
</li>
<li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整 数、零或正整数。</p>
</li>
</ol>
<p><strong>LinkedHashSet：</strong> 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法 操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并 通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操 作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可</p>
<h3 id="3-Map集合"><a href="#3-Map集合" class="headerlink" title="3.Map集合"></a><strong>3.Map集合</strong></h3><h4 id="1-HashMap-和-Hashtable-的区别"><a href="#1-HashMap-和-Hashtable-的区别" class="headerlink" title="1. HashMap 和 Hashtable 的区别"></a>1. HashMap 和 Hashtable 的区别</h4><ol>
<li><p><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（要保证线程安全的话就使用 ConcurrentHashMap 吧！）； </p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在 代码中使用它； </p>
</li>
<li><p><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键 所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。 </p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p>
<p> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来 的2倍。</p>
<p>②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充 为2的幂次方大小。也就是说 HashMap 总 是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</p>
</li>
<li><p> <strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ol>
<h4 id="2-ConcurrentHashMap-和-Hashtable-的区别"><a href="#2-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="2.ConcurrentHashMap 和 Hashtable 的区别"></a>2.ConcurrentHashMap 和 Hashtable 的区别</h4><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。 </p>
<ul>
<li><p><strong>底层数据结构：</strong>ConcurrentHashMap 数组+链表/红黑二叉树。Hashtable 采用 数组+链表 的形式</p>
</li>
<li><p><strong>实现线程安全的方式（重要）：</strong></p>
<p>① ConcurrentHashMap 使用 Node 数组+链表+红黑 树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。</p>
<p>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全， 效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</li>
</ul>
<h4 id="3-Map数据结构总结"><a href="#3-Map数据结构总结" class="headerlink" title="3.Map数据结构总结"></a>3.Map数据结构总结</h4><p><strong>HashMap：</strong>数组+链表/红黑树，</p>
<p><strong>LinkedHashMap:</strong>  继承自 HashMap，数组+链表/红黑树。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
<p><strong>HashTable:</strong> 数组+链表组成的，</p>
<p><strong>TreeMap:</strong> 红黑树（自平衡的排序二叉树）</p>
<h4 id="4-HashMap扩容机制"><a href="#4-HashMap扩容机制" class="headerlink" title="4.HashMap扩容机制"></a>4.HashMap扩容机制</h4><p><strong>当前存放新值（<em>注意不是替换已有元素位置时</em>）的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</strong></p>
<p>　　注：</p>
<p>　　（1）扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：put（“name”,”zhangsan”），而map里面原有数据&lt;”name”,”lisi”&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）</p>
<p>　　（2）扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</p>
<h2 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h2><h4 id="1-多线程的创建方式"><a href="#1-多线程的创建方式" class="headerlink" title="1.多线程的创建方式"></a>1.多线程的创建方式</h4><ul>
<li><p>继承 Thread 类</p>
</li>
<li><p>实现 runnable 、callable 接口</p>
</li>
<li><p>创建线程池</p>
</li>
</ul>
<h4 id="2-线程池的创建方式"><a href="#2-线程池的创建方式" class="headerlink" title="2.线程池的创建方式"></a>2.线程池的创建方式</h4><ul>
<li>通过 ExcutorService 创建</li>
<li>通过 Excutors 创建</li>
</ul>
<p>两种方式的异同：</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="二、Spring"><a href="#二、Spring" class="headerlink" title="二、Spring"></a>二、Spring</h2><h3 id="1-SpringMVC的工作原理？"><a href="#1-SpringMVC的工作原理？" class="headerlink" title="1.SpringMVC的工作原理？"></a>1.SpringMVC的工作原理？</h3><ul>
<li>用户向服务器发送请求，通过server.xml文件，请求被前端控制器DispatchServlet捕获；</li>
<li>DispatchServlet对URL进行解析，得到请求资源标识符（URI），通过HandlerMapping找到合适的处理器HandlerExcutionChain;</li>
<li>根据得到的处理器，DispatchServlet选择合适的适配器handlerAdapter处理请求；</li>
<li>handler处理完请求后，返回一个ModelAndView对象给DispatchServlet；</li>
<li>DispatchServlet将此对象通过ViewResolver进行处理，并得到渲染视图；</li>
<li>最后将Model中的参数进行解析，最终呈现出完整的视图返回给客户端；</li>
</ul>
<h3 id="2-常用注解有哪些？"><a href="#2-常用注解有哪些？" class="headerlink" title="2.常用注解有哪些？"></a>2.常用注解有哪些？</h3><h3 id="3-谈谈你对Spring的理解"><a href="#3-谈谈你对Spring的理解" class="headerlink" title="3.谈谈你对Spring的理解"></a>3.谈谈你对Spring的理解</h3><p>Spring是一个开源框架，为简化企业级应用开发而生，Spring是一个IOC和AOP容器框架</p>
<h3 id="4-Spring容器的主要核心是："><a href="#4-Spring容器的主要核心是：" class="headerlink" title="4.Spring容器的主要核心是："></a>4.Spring容器的主要核心是：</h3><h3 id="5-Bean的生命周期"><a href="#5-Bean的生命周期" class="headerlink" title="5.Bean的生命周期"></a>5.Bean的生命周期</h3><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050318374.png" alt="Spring的设计模式"></p>
<h2 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h2><h3 id="1-sql注入是什么？-和-的区别是什么"><a href="#1-sql注入是什么？-和-的区别是什么" class="headerlink" title="1.sql注入是什么？#{}和${}的区别是什么?"></a>1.sql注入是什么？#{}和${}的区别是什么?</h3><p>sql注入是指通过web表单输入恶意sql语句，激发数据库漏洞，而不是按设计者意图去执行sql语句。举例：select * from def_user where username=” <u>admin “  or  “a”=”a</u> “恒成立；</p>
<p>#{}是通过预编译处理，如select * from user where username=?,sql语义不会发生改变，在很大程度上可以防止sql注入</p>
<p>${}是字符串替换。在处理时，将 它替换成变量的值，不安全。</p>
<h3 id="2-MySQL性能优化有哪些？"><a href="#2-MySQL性能优化有哪些？" class="headerlink" title="2.MySQL性能优化有哪些？"></a>2.MySQL性能优化有哪些？</h3><ul>
<li>使用limit1</li>
<li>选择正确的数据库引擎</li>
<li>用not exists代替not in</li>
<li>对操作符进行优化，尽量不采用索引的操作符</li>
</ul>
<h2 id="四、Mybatis"><a href="#四、Mybatis" class="headerlink" title="四、Mybatis"></a>四、Mybatis</h2><h3 id="1、什么是-Mybatis？"><a href="#1、什么是-Mybatis？" class="headerlink" title="1、什么是 Mybatis？"></a>1、什么是 Mybatis？</h3><p>（1） Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开<br>发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、<br>创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制<br>sql 执行性能，灵活度高。<br>（2） MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成<br>数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果<br>集。<br>（3） 通过 xml 文件或注解的方式将要执行的各种 statement 配置起来，并通<br>过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql<br>语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。<br>（从执行 sql 到返回 result 的过程）。</p>
<h2 id="五、Redis"><a href="#五、Redis" class="headerlink" title="五、Redis"></a>五、Redis</h2><p><img src="https://cdn.jsdelivr.net/gh/yoon286/Pic@main/img/202202050319649.png"></p>
<h2 id="六、RabbitMQ"><a href="#六、RabbitMQ" class="headerlink" title="六、RabbitMQ"></a>六、RabbitMQ</h2><h3 id="1、什么是rabbitmq？"><a href="#1、什么是rabbitmq？" class="headerlink" title="1、什么是rabbitmq？"></a>1、什么是rabbitmq？</h3><p><strong>答：</strong></p>
<p>采用AMQP高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦。</p>
<h3 id="2、为什么要使用rabbitmq？"><a href="#2、为什么要使用rabbitmq？" class="headerlink" title="2、为什么要使用rabbitmq？"></a>2、为什么要使用rabbitmq？</h3><p><strong>答：</strong> 1、在分布式系统下具备异步,削峰,负载均衡等一系列高级功能；</p>
<p>2、拥有持久化的机制，进程消息，队列中的信息也可以保存下来。</p>
<p>3、实现消费者和生产者之间的解耦。</p>
<p>4、对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。</p>
<p>5、可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单。</p>
<h3 id="4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"><a href="#4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？" class="headerlink" title="4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？"></a>4、如何确保消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息？</h3><p>答：<br>发送方确认模式<br>1.将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。<br>2.一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。<br>3.如果 RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（notacknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。<br>接收方确认机制<br>接收方消息确认机制<br>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。保证数据的最终一致性；</p>
<h3 id="5-如何避免消息重复投递或重复消费？"><a href="#5-如何避免消息重复投递或重复消费？" class="headerlink" title="5.如何避免消息重复投递或重复消费？"></a>5.如何避免消息重复投递或重复消费？</h3><p><strong>答：</strong></p>
<p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；</p>
<p>在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID 等）作为去重的依据，避免同一条消息被重复消费。</p>
<h3 id="6-死信队列"><a href="#6-死信队列" class="headerlink" title="6.死信队列"></a>6.死信队列</h3><p>一个消息是有死亡状态的，它会被发送到一个指定的队列中，这个队列是一个普通的队列，根据他的功能，我们叫他死信队列。</p>
<h3 id="8、消息怎么路由？"><a href="#8、消息怎么路由？" class="headerlink" title="8、消息怎么路由？"></a>8、消息怎么路由？</h3><p>答：<br>消息提供方-&gt;路由-&gt;一至多个队列<br>消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。<br>通过队列路由键，可以把队列绑定到交换器上。<br>消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；<br>常用的交换器主要分为一下三种<br>1.fanout：如果交换器收到消息，将会广播到所有绑定的队列上<br>2.direct：如果路由键完全匹配，消息就被投递到相应的队列<br>3.topic：可以使来自不同源头的消息能够到达同一个队列。 使用topic交换器时，可以使用通配符</p>
<h3 id="七、ehcache"><a href="#七、ehcache" class="headerlink" title="七、ehcache"></a>七、ehcache</h3><p>ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。</p>
<p>Spring Cache 是 Spring 提供的一整套的缓存解决方案。虽然它本身并没有提供缓存的实现，但是它提供了一整套的接口和代码规范、配置、注解等，这样它就可以整合各种缓存方案了，比如 Redis、Ehcache，我们也就不用关心操作缓存的细节。</p>
<p>Spring 提供了四个注解来声明缓存规则。@Cacheable，@CachePut，@CacheEvict，@Caching。</p>
<h3 id="八、简历说明"><a href="#八、简历说明" class="headerlink" title="八、简历说明"></a>八、简历说明</h3><p>独立的模块设计+使用count判断是否存在，改为limit 1</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>实践知识整理</title>
    <url>/2021/08/03/%E5%AE%9E%E4%B9%A0%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="知识内容"><a href="#知识内容" class="headerlink" title="知识内容"></a>知识内容</h1><h2 id="WebServer"><a href="#WebServer" class="headerlink" title="WebServer"></a>WebServer</h2><h3 id="什么是HTTP请求头-响应头"><a href="#什么是HTTP请求头-响应头" class="headerlink" title="什么是HTTP请求头/响应头"></a>什么是HTTP请求头/响应头</h3><p>1)请求(客户端-&gt;服务端[request])<br>     GET(请求的方式)     /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)<br>     Accept: <em>/</em>(客户端能接收的资源类型)<br>     Accept-Language: en-us(客户端接收的语言类型)<br>     Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>     Host: localhost:8080(连接的目标主机和端口号)<br>     Referer: <a href="http://localhost/links.asp(%E5%91%8A%E8%AF%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA%E9%87%8C)">http://localhost/links.asp(告诉服务器我来自于哪里)</a><br>     User-Agent: Mozilla/4.0(客户端版本号的名字)<br>     Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>     If-Modified-Since: Tue, 11 Jul     2000 18:23:51 GMT(缓存时间)<br>     Cookie(客户端暂存服务端的信息)<br>     Date: Tue, 11 Jul 2000     18:23:51 GMT(客户端请求服务端的时间)  </p>
<span id="more"></span>

<p>2)响应(服务端-&gt;客户端[response])<br>​        HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)<br>​     Location:     <a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a>(服务端需要客户端访问的页面路径)<br>​     Server:apache     tomcat(服务端的Web服务端名)<br>​     Content-Encoding:     gzip(服务端能够发送压缩编码类型)<br>​     Content-Length: 80(服务端发送的压缩数据的长度)<br>​     Content-Language: zh-cn(服务端发送的语言类型)<br>​     Content-Type:     text/html; charset=GB2312(服务端发送的类型及采用的编码方式)<br>​     Last-Modified:     Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)<br>​     Refresh:     1;url=<a href="https://link.zhihu.com/?target=http://www.it315.org">http://www.it315.org</a>(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)<br>​     Content-Disposition: attachment;     filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)<br>​     Transfer-Encoding:     chunked(分块传递数据到客户端）<br>​     Set-Cookie:SS=Q0=5Lb_nQ;     path=/search(服务端发送到客户端的暂存数据)<br>​     Expires:     -1//3种(服务端禁止客户端缓存页面数据)<br>​     Cache-Control:     no-cache(服务端禁止客户端缓存页面数据)<br>​     Pragma: no-cache(服务端禁止客户端缓存页面数据)<br>​     Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  </p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="1-匿名内部类"><a href="#1-匿名内部类" class="headerlink" title="1.匿名内部类"></a>1.匿名内部类</h3><p>匿名内部类也就是没有名字的内部类，正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p>
<p>但使用匿名内部类还有个前提条件：<strong>必须继承一个父类或实现一个接口</strong></p>
<h4 id="实例1-不使用匿名内部类来实现抽象方法"><a href="#实例1-不使用匿名内部类来实现抽象方法" class="headerlink" title="实例1:不使用匿名内部类来实现抽象方法"></a>实例1:不使用匿名内部类来实现抽象方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Child();</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong> eat something</p>
<p>可以看到，我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用</p>
<p>但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类岂不是很麻烦？</p>
<p>这个时候就引入了匿名内部类</p>
<h4 id="实例2：匿名内部类的基本实现"><a href="#实例2：匿名内部类的基本实现" class="headerlink" title="实例2：匿名内部类的基本实现"></a>实例2：匿名内部类的基本实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong> eat something</p>
<p>可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p>
<p>这样便可以省略一个类的书写,并且，匿名内部类还能用于接口上</p>
<h4 id="实例3：在接口上使用匿名内部类"><a href="#实例3：在接口上使用匿名内部类" class="headerlink" title="实例3：在接口上使用匿名内部类"></a>实例3：在接口上使用匿名内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong> eat something</p>
<p>由上面的例子可以看出，<strong>只要一个类是抽象的或是一个接口</strong>，那么其子类中的方法都可以使用匿名内部类来实现</p>
<h3 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2.Lambda表达式"></a>2.Lambda表达式</h3><p>对于单方法接口，即一个接口只定义了一种方法，我们可以只写出方法定义：</p>
<p>即简化匿名内部类的方式，<strong>其核心是一个接口实现类的覆盖重写，返回一个接口对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化后</span></span><br><span class="line">Person p = ()-&gt;System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure>

<h3 id="3-联系与区别"><a href="#3-联系与区别" class="headerlink" title="3.联系与区别"></a>3.联系与区别</h3><ul>
<li>匿名内部类可以为任意接口创建实例——不管接口包含多少个抽象方法，只要匿名内部类实现所有的抽象方法即可；但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例；但 Lambda 表达式只能为函数式接口创建实例。</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法；但 Lambda 表达式的代码块不允许调用接口中定义的默认方法。</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="图谱"><a href="#图谱" class="headerlink" title="图谱"></a>图谱</h3><p><img src="https://img-blog.csdn.net/20131213145346421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p5XzE5ODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<h3 id="Data-Manipulation-Language"><a href="#Data-Manipulation-Language" class="headerlink" title="Data Manipulation Language"></a>Data Manipulation Language</h3><h4 id="连接词："><a href="#连接词：" class="headerlink" title="连接词："></a>连接词：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">Table</span> <span class="keyword">where</span></span><br><span class="line"><span class="keyword">column</span> <span class="keyword">like</span> <span class="string">&#x27;name_%&#x27;</span></span><br><span class="line"><span class="keyword">column</span> <span class="keyword">between</span> <span class="string">&#x27;100&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;150&#x27;</span></span><br><span class="line"><span class="keyword">column</span> <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">in</span> (column1,column2...)</span><br></pre></td></tr></table></figure>

<h4 id="通配符："><a href="#通配符：" class="headerlink" title="通配符："></a>通配符：</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">%:任意字符</span></span><br><span class="line"><span class="string">_:任意单个字符</span></span><br><span class="line">[ ]<span class="string">:指定范围</span> <span class="string">([a-f])</span> <span class="string">或集合</span> <span class="string">([abcdef])</span> <span class="string">中的任何单个字符</span></span><br><span class="line">[<span class="string">^</span>]<span class="string">:不属于指定范围</span> <span class="string">([a-f])</span> <span class="string">或集合</span> <span class="string">([abcdef])</span> <span class="string">的任何单个字符</span></span><br><span class="line"><span class="string">escape</span> <span class="string">&#x27;\&#x27;：转义,select * from table where name like &#x27;</span><span class="string">user\_&#x27;</span> <span class="string">escape</span> <span class="string">&#x27;\&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="限定词"><a href="#限定词" class="headerlink" title="限定词:"></a>限定词:</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">distinct:唯一值</span></span><br><span class="line"><span class="string">order</span> <span class="string">by：排序规则，desc/asc</span></span><br><span class="line"><span class="string">group</span> <span class="string">by:分组.having</span> <span class="string">group_conditon</span></span><br><span class="line"><span class="string">limit</span> <span class="string">nums:限制个数</span></span><br><span class="line"><span class="string">offset</span> <span class="string">nums:从第几个开始</span></span><br><span class="line"><span class="string">Is</span> <span class="string">Not/Is</span> <span class="literal">NULL</span><span class="string">:判空</span></span><br></pre></td></tr></table></figure>

<h4 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">table</span> A </span><br><span class="line"><span class="keyword">inner</span><span class="operator">/</span><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span><span class="operator">/</span><span class="keyword">full</span> </span><br><span class="line"><span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">Table</span> B </span><br><span class="line"><span class="keyword">on</span> conditions</span><br></pre></td></tr></table></figure>

<h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单行函数:</span><br><span class="line">    字符函数、数值函数、日期函数、转换函数、通用函数</span><br><span class="line">组合函数:</span><br><span class="line">     count、min、max、avg、sum</span><br></pre></td></tr></table></figure>

<h3 id="Data-Define-Language"><a href="#Data-Define-Language" class="headerlink" title="Data Define Language"></a>Data Define Language</h3><h4 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h4><p>用于定义数据库的三级结构，包括外模式、概念模式、内模式及其相互之间的映像，定义数据的完整性、安全控制等约束</p>
<h4 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">create table if not exits MyTable&#123;</span><br><span class="line">    column1 DATATYPE TABLECONSTRAINT <span class="keyword">DEFAULT</span> default_value,</span><br><span class="line">    column2 DATATYPE TABLECONSTRAINT <span class="keyword">DEFAULT</span> default_value,</span><br><span class="line">&#125;</span><br><span class="line">DATATYPE:</span><br><span class="line">    <span class="type">Integer</span>,<span class="type">boolean</span></span><br><span class="line">TABLECONSTRAINT:</span><br><span class="line">    <span class="keyword">primary</span> keys,autoincrement,<span class="keyword">unique</span>,<span class="keyword">not</span> <span class="keyword">null</span>,<span class="keyword">check</span>,<span class="keyword">foreign</span>      key</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> MyTable</span><br><span class="line">① <span class="keyword">add</span> <span class="keyword">column</span> datatype tableconstraint <span class="keyword">default</span> default_value</span><br><span class="line">② <span class="keyword">drop</span> column_to_be_deleted</span><br><span class="line">③ rename <span class="keyword">to</span> new_table_name</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> MyTable</span><br></pre></td></tr></table></figure>

<h3 id="Data-Control-Language"><a href="#Data-Control-Language" class="headerlink" title="Data Control Language"></a>Data Control Language</h3><p>数据库控制语言：授权，角色控制等</p>
<ul>
<li><p>GRANT – 为用户赋予访问权限</p>
</li>
<li><p>REVOKE – 撤回授权权限</p>
</li>
</ul>
<h3 id="Transaction-Control-Language"><a href="#Transaction-Control-Language" class="headerlink" title="Transaction Control Language"></a>Transaction Control Language</h3><p>事务的概念：要么全部执行，要么全部不执行。<br>​事务的acid属性：atomicity、consistency、isolation、durability<br>​事务的创建：隐式事务、显示事务。事务具有明显的开启和结束标记。</p>
<h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="1-GitFlow"><a href="#1-GitFlow" class="headerlink" title="1. GitFlow"></a>1. GitFlow</h2><p>可以在idea里面直接看到流程：<strong>提交需要反复确认，然后进行拉取</strong></p>
<p><img src="assets/image-20210818173247374.png" alt="image-20210818173247374"></p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">Function</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>master</strong></td>
<td align="left">存放随时可供生产环境中的部署的代码</td>
</tr>
<tr>
<td align="left"><strong>develop</strong></td>
<td align="left">存放当前最新开发成果的分支，当代码足够稳定时可以合并到master分支上去。</td>
</tr>
<tr>
<td align="left"><strong>feature</strong></td>
<td align="left">开发新功能使用，最终合并到develop分支或抛弃掉</td>
</tr>
<tr>
<td align="left"><strong>release</strong></td>
<td align="left">做小的缺陷修正、准备发布版本所需的各项说明信息</td>
</tr>
<tr>
<td align="left"><strong>hotfix</strong></td>
<td align="left">代码的紧急修复工作</td>
</tr>
</tbody></table>
<p>查看Git工作区、暂存区的变更情况（可以知道哪些没有commit、哪些没有被Git追踪）：<code>git status</code></p>
<p>拉取远程最新的变更到本地：<code>git fetch</code></p>
<p>切换分支：<code>git checkout 分支名</code></p>
<p>将代码还原到某个版本(包括工作目录)：<code>git reset --hard 版本号</code></p>
<p>查看Git的提交(commit)记录：<code>git log</code></p>
<p>将代码还原到某个版本后，后悔了，想重新回去，但在提交记录已经找不到了。<code>git reset --hard</code> 把<code>reset 之后的 commit</code>都给抹杀掉了。找到最近的执行Git命令：<code>git reflog</code></p>
<p>还原到某个版本了，现在我为了稳健，不想再原来的分支上修改了，再<strong>新建一个分支</strong>吧（<code>-b</code> 参数把当前分支切换到了要创建的分支上）：<code>git checkout -b 分支名</code></p>
<p>我们把上一次还是”相对稳健“的分支合并到我新建的分支上：<code>git merge 分支</code></p>
<p>突然想看看现在有多少个分支：<code>git branch -a</code></p>
<p>新增几个文件了，随手<code>git add</code>一下吧</p>
<p>改得差不多了，随手<code>git commit -m</code>一下吧，最好还是<strong>写好备注</strong>，不然以后等改多了，你都不知道你改了什么啦。</p>
<p>改完了，提交到远程吧：<code>git push</code></p>
<p>想把远程分支最新的代码给拉下来，然后合并到本地上。我们可以用<code>git fetch</code>和<code>git merge</code>来实现，也可以通过<code>git pull</code>来实现。一般我用的都是<code>git fetch</code>+<code>git merge</code>，这样会更加<strong>可控</strong>一些</p>
<p>有的时候，本地分支在master分支，然后忘了切其他的分支去修改，直接在master改了，然后也push到远程了。等你发现的时候，你会真的想骂自己。</p>
<p>咋办？最简单的办法其实我们还是可以<code>git reset --hard</code>到对应的版本，然后将其修改或者复原，再强制提交到<code>master</code>分支：<code>git push -u origin/master -f</code></p>
<h2 id="2-idea-插件"><a href="#2-idea-插件" class="headerlink" title="2. idea 插件"></a>2. idea 插件</h2><h3 id="2-1-RestfulToolkit—RESTful服务开发"><a href="#2-1-RestfulToolkit—RESTful服务开发" class="headerlink" title="2.1 RestfulToolkit—RESTful服务开发"></a>2.1 RestfulToolkit—RESTful服务开发</h3><ul>
<li>2.1.1 根据 URL 直接跳转到对应的方法定义 ( Ctrl \ or Ctrl Alt N );</li>
<li>2.1.2 提供了一个 Services tree 的显示窗口;</li>
<li>2.1.3 一个简单的 http 请求工具;</li>
<li>2.1.4 在请求方法上添加了有用功能: 复制生成 URL;复制方法参数…</li>
<li>2.1.5 其他功能: java 类上添加 Convert to JSON 功能，格式化 json 数据 ( Windows: Ctrl + Enter; Mac: Command + Enter )。</li>
</ul>
<h3 id="2-2-快捷键"><a href="#2-2-快捷键" class="headerlink" title="2.2 快捷键"></a>2.2 快捷键</h3><p><code>Ctrl+Shift+Enter</code>   完善整条语句、分号、if语句等</p>
<p><code>Ctrl+W</code>   扩大选取范围</p>
<p><code>Ctrl+F8 </code>  打断点</p>
<p><code>Shift+F9</code>   debug</p>
<p><code>F7 F8 F9</code>   进入方法、下一步、下个断点</p>
<p>ctrl+T 直接拉取git更新</p>
<p>ctrl+alt+shift+C  copy reference</p>
<h1 id="用户评级-项目"><a href="#用户评级-项目" class="headerlink" title="用户评级 项目"></a>用户评级 项目</h1><h2 id="PageInfo"><a href="#PageInfo" class="headerlink" title="PageInfo"></a>PageInfo</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Request URL: </span><br><span class="line">/api/audiences?orderColumn=createTime&amp;orderType=desc&amp;page=1&amp;pagesize=30&amp;readState=READ_SUCCESS</span><br></pre></td></tr></table></figure>

<p>读取过程 : PageInterceptor.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageInfo page = <span class="keyword">new</span> PageInfo();</span><br><span class="line">            page.setCurrent(<span class="keyword">this</span>.getIntValue(request, <span class="string">&quot;page&quot;</span>, <span class="number">1</span>));</span><br><span class="line">            page.setPagesize(<span class="keyword">this</span>.getIntValue(request, <span class="string">&quot;pagesize&quot;</span>, annotation.size()));</span><br><span class="line">            String orderColumn = request.getParameter(<span class="string">&quot;orderColumn&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="项目组件"><a href="#项目组件" class="headerlink" title="项目组件"></a>项目组件</h2><ul>
<li><p>parent : crius</p>
</li>
<li><p>被dependencyManagement管理版本号的组件 :  </p>
<p>opencv、log4j、reflections 、 lombok 、compress 、commons-jcs-core 、kryo 、httpclient 、mapstruct 、aws-java-sdk-s3 、com.amazonaws 、jmespath-java 、commons-collections 、spring-cloud-dependencies 、dependencies </p>
</li>
<li><p>har-manager模块组件：</p>
<p>spring-cloud-starter-openfeign 、spring-cloud-starter-netflix-hystrix 、spring-boot-starter-cache 、ehcache、crius-spring-boot-starter 、mybatis 、crius-oss-amazon-s3-spring-boot-starter 、crius-oss-azure-storage-spring-boot-starter 、jmespath-java 、commons-collections、spring-boot-starter-actuator 、spring-boot-starter-rabbitmq 、spring-cloud-starter-alibaba-nacos-config</p>
</li>
</ul>
<h2 id="Oauth授权"><a href="#Oauth授权" class="headerlink" title="Oauth授权"></a>Oauth授权</h2><p>1.网关拦截</p>
<p>由devops平台上的网关决定redirect地址，Oauth进行授权鉴权，如没有权限，用户拿着token去访问第三方平台</p>
<p>注：微服务技术解决方案下的，网关至少需要具备图示基本功能。</p>
<ol>
<li>网关作为单点入口，完成统一的请求管理</li>
<li>免去客户端直接对接众多微服务的复杂性，采用单点入口，实现路由转发，从而实现服务调用</li>
<li>服务对于整个系统来讲，是不稳定的，那么网关，需要进行限流熔断，保持系统的稳定与分区容错性</li>
<li>对于服务调用的链路，网关有职责进行记录，日志监控，保证整个系统，在监控下工作</li>
<li>系统可能不仅仅是由自有客户端调用，很多时候，系统开放能力API给外部，因此网关需要安全认证，来保证安全</li>
</ol>
<p>2.Security授权</p>
<p>Security通过authLoginFilter同步hac用户信息</p>
<h2 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h2><ul>
<li><p>父pom需要添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>。</p>
</li>
<li><p>父pom需要用<code>&lt;modules&gt;&lt;module&gt;子module名&lt;/module&gt;&lt;/modules&gt;</code>注明子module有哪些。</p>
</li>
<li><p>父pom声明依赖时<code>&lt;dependencies&gt;</code>外要嵌套<code>&lt;dependencyManagement&gt;</code>才能被子pom继承到，我就是忘了这点。</p>
</li>
<li><p>子pom需要通过<code>&lt;parent&gt;&lt;/parent&gt;</code>指定父项目，声明依赖时就默认会用父pom中的版本了。</p>
</li>
</ul>
<h2 id="项目创建顺序"><a href="#项目创建顺序" class="headerlink" title="项目创建顺序"></a>项目创建顺序</h2><p>业务  - &gt;  授权  - &gt;  性能优化</p>
<h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><ul>
<li>entity\dao\mapper\vo写在repository中</li>
<li>service\特有的entity写在特定的module中</li>
</ul>
<h2 id="MyBatis枚举类映射"><a href="#MyBatis枚举类映射" class="headerlink" title="MyBatis枚举类映射"></a>MyBatis枚举类映射</h2><p><strong>mybatis默认的枚举类型处理器 :</strong></p>
<ul>
<li><p>EnumTypeHandler<br>mybatis的默认枚举类型处理器，将枚举类型的name持久化到数据库；</p>
</li>
<li><p>EnumOrdinalTypeHandler<br>mybatis原生支持的另一种枚举类型处理器，将枚举类型的索引序号持久化到数据库，需要全局配置或者在需要的字段上单独配置；</p>
</li>
</ul>
<p><strong>mybatis配置全局默认枚举类型处理器 :  defaultEnumTypeHandler</strong></p>
<ul>
<li>mybatis在3.4.5及之后版本中，新增了一个指定全局默认枚举类型处理器的配置项 :  <strong>default-enum-type-handler</strong><br>在mybatis-config.xml中添加如下配置即可使自定义处理器全局生效，解决了之前新增枚举都需要单独配置的烦恼；</li>
</ul>
<p><img src="assets/image-20210910184840551.png" alt="image-20210910184840551"></p>
<p><img src="assets/image-20210910184912954.png" alt="image-20210910184912954"></p>
<h2 id="使用TypeHandler将List集合数据存入数据库"><a href="#使用TypeHandler将List集合数据存入数据库" class="headerlink" title="使用TypeHandler将List集合数据存入数据库"></a>使用TypeHandler将List集合数据存入数据库</h2><p><a href="https://www.dtmao.cc/news_show_785309.shtml">https://www.dtmao.cc/news_show_785309.shtml</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes(value=JdbcType.VARCHAR)</span></span><br><span class="line"><span class="meta">@MappedTypes(List.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListToVarchar</span> <span class="keyword">implements</span> <span class="title">TypeHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历List类型的入参，转换为JSON格式，使用Statement对象插入数据库</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, List&lt;String&gt; objectList, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(objectList.isEmpty())&#123;</span><br><span class="line">            ps.setString(i,<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = JSON.toJSONString(objectList);</span><br><span class="line">        ps.setString(i,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取String类型的结果，使用parseObject将json对象转换为java对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(resultSet.getString(s),<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取String类型的结果，使用parseObject将json对象转换为java对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String s = resultSet.getString(i);</span><br><span class="line">        <span class="keyword">return</span>  JSON.parseObject(s,<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取String类型的结果，使用parseObject将json对象转换为java对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getResult</span><span class="params">(CallableStatement callableStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String s = callableStatement.getString(i);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(s,<span class="keyword">new</span> TypeReference&lt;List&lt;String&gt;&gt;() &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="开发避坑"><a href="#开发避坑" class="headerlink" title="开发避坑"></a>开发避坑</h1><h2 id="1-判空"><a href="#1-判空" class="headerlink" title="1.判空"></a>1.判空</h2><ul>
<li><p>Constant.equals(Variables);</p>
</li>
<li><p>Java中判断list为空(CollectionUtils.isEmpty)等同于 (list==null&amp;&amp;list.isEmpty())</p>
</li>
</ul>
<h2 id="2-typeHandler匹配问题"><a href="#2-typeHandler匹配问题" class="headerlink" title="2.typeHandler匹配问题"></a>2.typeHandler匹配问题</h2><ul>
<li>使用typeHandler去数据库中查询匹配时，注意序列化和反序列化的问题，需要二者hashcode完全一致，所以最好还是从数据库中找出json，映射为实体对象，在判断是否匹配</li>
<li>错误示例： select语句中，即使数据库中json内容一致，但仍旧不能匹配</li>
<li><img src="assets/image-20211116161549936.png" alt="image-20211116161549936"></li>
</ul>
<h1 id="隐私条款项目"><a href="#隐私条款项目" class="headerlink" title="隐私条款项目"></a>隐私条款项目</h1><h2 id="1-定时任务"><a href="#1-定时任务" class="headerlink" title="1.定时任务"></a>1.定时任务</h2><p><strong>- @SchedulerLock注解：为方法加上锁。</strong></p>
<p>name属性（锁的名称）必须指定，每次只能执行一个具有相同名字的任务。</p>
<p><strong>- lockAtMostFor属性，指定执行节点死亡时应该保留锁的时间。</strong></p>
<p>设置锁的最大持有时间,为了解决如果持有锁的节点挂了,无法释放锁,其他节点无法进行下一次任务。设置了最大持有时间，当持有时间到了自动释放锁，不影响下一次执行。</p>
<p><strong>- lockAtLeastFor属性，指定保留锁的最短时间。</strong></p>
<p>主要目的是在任务非常短的且节点之间存在时钟差异的情况下防止多个节点执行。这个属性是锁的持有时间。设置了多少就一定会持有多长时间，在此期间，下一次任务执行时，其他节点包括它本身是不会执行任务的。</p>
<h2 id="2-隐私条款模板"><a href="#2-隐私条款模板" class="headerlink" title="2.隐私条款模板"></a>2.隐私条款模板</h2><p>接口文档</p>
<ul>
<li>查看模板   GET     /api/templates</li>
<li>新建模板   POST    /api/templates</li>
<li>编辑模板  PATCH  /api/templates/{templateId}</li>
<li>删除模板  DELETE    /api/templates/{templateId}</li>
</ul>
<h2 id="3-校验"><a href="#3-校验" class="headerlink" title="3.校验"></a>3.校验</h2><ul>
<li>@Unique   name字段一致，表示绑定在一起校验<img src="assets/image-20211104145855450.png" alt="image-20211104145855450"></li>
</ul>
<h2 id="4-特殊用法"><a href="#4-特殊用法" class="headerlink" title="4.特殊用法"></a>4.特殊用法</h2><ul>
<li>```java<br>/**<ul>
<li>则在路径中悄悄接收projectIds</li>
<li>/<br>@JsonIgnore<br>private List<Long> projectIds;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 通过一系列Id查找</span><br><span class="line">  </span><br><span class="line">  &#96;&#96;&#96;xml</span><br><span class="line">  &lt;select id&#x3D;&quot;getClauses&quot; resultType&#x3D;&quot;long&quot;&gt;</span><br><span class="line">      select id from def_privacy_clause where project_id in</span><br><span class="line">      &lt;foreach collection&#x3D;&quot;list&quot; item&#x3D;&quot;id&quot; open&#x3D;&quot;(&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;,&quot;&gt;</span><br><span class="line">          #&#123;id&#125;</span><br><span class="line">      &lt;&#x2F;foreach&gt;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-部署踩坑"><a href="#3-部署踩坑" class="headerlink" title="3.部署踩坑"></a>3.部署踩坑</h2><h4 id="1-消息已发，计算端没有日志"><a href="#1-消息已发，计算端没有日志" class="headerlink" title="(1)消息已发，计算端没有日志"></a>(1)消息已发，计算端没有日志</h4><ul>
<li><p>检查MQ配置</p>
</li>
<li><p>检查消费者</p>
</li>
<li><p>计算端磁盘已满</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
